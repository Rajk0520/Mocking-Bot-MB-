
Instrument.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003c  00800200  00001f46  00001fda  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001f46  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000464  0080023c  0080023c  00002016  2**0
                  ALLOC
  3 .stab         00001be4  00000000  00000000  00002018  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000583  00000000  00000000  00003bfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  00004180  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002696  00000000  00000000  00004320  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008bb  00000000  00000000  000069b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000fea  00000000  00000000  00007271  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006e8  00000000  00000000  0000825c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ae8  00000000  00000000  00008944  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001a68  00000000  00000000  0000942c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      14:	0c 94 df 05 	jmp	0xbbe	; 0xbbe <__vector_5>
      18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      34:	0c 94 07 06 	jmp	0xc0e	; 0xc0e <__vector_13>
      38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e6 e4       	ldi	r30, 0x46	; 70
      fc:	ff e1       	ldi	r31, 0x1F	; 31
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ac 33       	cpi	r26, 0x3C	; 60
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	16 e0       	ldi	r17, 0x06	; 6
     110:	ac e3       	ldi	r26, 0x3C	; 60
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a0 3a       	cpi	r26, 0xA0	; 160
     11a:	b1 07       	cpc	r27, r17
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 54 06 	call	0xca8	; 0xca8 <main>
     122:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <_exit>

00000126 <__bad_interrupt>:
     126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <i2cSetBitrate>:
void i2cSetBitrate(unsigned short bitrateKHz)
{
	unsigned char bitrate_div;
	// set i2c bitrate
	// SCL freq = F_CPU/(16+2*TWBR))
	cbi(TWSR, TWPS0);
     12a:	e9 eb       	ldi	r30, 0xB9	; 185
     12c:	f0 e0       	ldi	r31, 0x00	; 0
     12e:	20 81       	ld	r18, Z
     130:	2e 7f       	andi	r18, 0xFE	; 254
     132:	20 83       	st	Z, r18
	cbi(TWSR, TWPS1);
     134:	20 81       	ld	r18, Z
     136:	2d 7f       	andi	r18, 0xFD	; 253
     138:	20 83       	st	Z, r18
	
	//calculate bitrate division	
	bitrate_div = ((14745600/4000l)/bitrateKHz);
     13a:	9c 01       	movw	r18, r24
     13c:	40 e0       	ldi	r20, 0x00	; 0
     13e:	50 e0       	ldi	r21, 0x00	; 0
     140:	66 e6       	ldi	r22, 0x66	; 102
     142:	7e e0       	ldi	r23, 0x0E	; 14
     144:	80 e0       	ldi	r24, 0x00	; 0
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <__divmodsi4>
	if(bitrate_div >= 16)
     14c:	20 31       	cpi	r18, 0x10	; 16
     14e:	40 f0       	brcs	.+16     	; 0x160 <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
     150:	30 e0       	ldi	r19, 0x00	; 0
     152:	20 51       	subi	r18, 0x10	; 16
     154:	30 40       	sbci	r19, 0x00	; 0
     156:	12 f4       	brpl	.+4      	; 0x15c <i2cSetBitrate+0x32>
     158:	2f 5f       	subi	r18, 0xFF	; 255
     15a:	3f 4f       	sbci	r19, 0xFF	; 255
     15c:	35 95       	asr	r19
     15e:	27 95       	ror	r18
	outb(TWBR, bitrate_div);
     160:	20 93 b8 00 	sts	0x00B8, r18
}
     164:	08 95       	ret

00000166 <i2cInit>:
 *********************/

void i2cInit(void)
{
	// set i2c bit rate to 40KHz
	i2cSetBitrate(100);
     166:	84 e6       	ldi	r24, 0x64	; 100
     168:	90 e0       	ldi	r25, 0x00	; 0
     16a:	0e 94 95 00 	call	0x12a	; 0x12a <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);	// Enable TWI
     16e:	ec eb       	ldi	r30, 0xBC	; 188
     170:	f0 e0       	ldi	r31, 0x00	; 0
     172:	80 81       	ld	r24, Z
     174:	84 60       	ori	r24, 0x04	; 4
     176:	80 83       	st	Z, r24
}
     178:	08 95       	ret

0000017a <i2cSendStart>:
	outb(TWBR, bitrate_div);
}

void i2cSendStart(void)
{
	WRITE_sda();
     17a:	51 9a       	sbi	0x0a, 1	; 10
	// send start condition
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     17c:	84 ea       	ldi	r24, 0xA4	; 164
     17e:	80 93 bc 00 	sts	0x00BC, r24
}
     182:	08 95       	ret

00000184 <i2cSendStop>:

void i2cSendStop(void)
{
	// transmit stop condition
        TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
     184:	84 e9       	ldi	r24, 0x94	; 148
     186:	80 93 bc 00 	sts	0x00BC, r24
}
     18a:	08 95       	ret

0000018c <i2cWaitForComplete>:
void i2cWaitForComplete(void)
{
	int i = 0;		//time out variable
	
	// wait for i2c interface to complete operation
    while ((!(TWCR & (1<<TWINT))) && (i < 90))
     18c:	80 91 bc 00 	lds	r24, 0x00BC
     190:	88 23       	and	r24, r24
     192:	4c f0       	brlt	.+18     	; 0x1a6 <i2cWaitForComplete+0x1a>
     194:	8a e5       	ldi	r24, 0x5A	; 90
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	ec eb       	ldi	r30, 0xBC	; 188
     19a:	f0 e0       	ldi	r31, 0x00	; 0
     19c:	20 81       	ld	r18, Z
     19e:	22 23       	and	r18, r18
     1a0:	14 f0       	brlt	.+4      	; 0x1a6 <i2cWaitForComplete+0x1a>
     1a2:	01 97       	sbiw	r24, 0x01	; 1
     1a4:	d9 f7       	brne	.-10     	; 0x19c <i2cWaitForComplete+0x10>
     1a6:	08 95       	ret

000001a8 <i2cReceiveByte>:
}

void i2cReceiveByte(unsigned char ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
     1a8:	88 23       	and	r24, r24
     1aa:	39 f0       	breq	.+14     	; 0x1ba <i2cReceiveByte+0x12>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
     1ac:	ec eb       	ldi	r30, 0xBC	; 188
     1ae:	f0 e0       	ldi	r31, 0x00	; 0
     1b0:	80 81       	ld	r24, Z
     1b2:	8f 70       	andi	r24, 0x0F	; 15
     1b4:	80 6c       	ori	r24, 0xC0	; 192
     1b6:	80 83       	st	Z, r24
     1b8:	08 95       	ret
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
     1ba:	ec eb       	ldi	r30, 0xBC	; 188
     1bc:	f0 e0       	ldi	r31, 0x00	; 0
     1be:	80 81       	ld	r24, Z
     1c0:	8f 70       	andi	r24, 0x0F	; 15
     1c2:	80 68       	ori	r24, 0x80	; 128
     1c4:	80 83       	st	Z, r24
     1c6:	08 95       	ret

000001c8 <i2cGetReceivedByte>:
}

unsigned char i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
     1c8:	80 91 bb 00 	lds	r24, 0x00BB
}
     1cc:	08 95       	ret

000001ce <i2cGetStatus>:

unsigned char i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
     1ce:	80 91 b9 00 	lds	r24, 0x00B9
}
     1d2:	08 95       	ret

000001d4 <delay_ms>:

void delay_ms(uint16_t x)
{
  uint8_t y, z;
  for ( ; x > 0 ; x--){
     1d4:	00 97       	sbiw	r24, 0x00	; 0
     1d6:	59 f4       	brne	.+22     	; 0x1ee <delay_ms+0x1a>
     1d8:	08 95       	ret
	...
    for ( y = 0 ; y < 90 ; y++){
      for ( z = 0 ; z < 6 ; z++){
        asm volatile ("nop");
     1e6:	21 50       	subi	r18, 0x01	; 1

void delay_ms(uint16_t x)
{
  uint8_t y, z;
  for ( ; x > 0 ; x--){
    for ( y = 0 ; y < 90 ; y++){
     1e8:	c1 f7       	brne	.-16     	; 0x1da <delay_ms+0x6>
}

void delay_ms(uint16_t x)
{
  uint8_t y, z;
  for ( ; x > 0 ; x--){
     1ea:	01 97       	sbiw	r24, 0x01	; 1
     1ec:	11 f0       	breq	.+4      	; 0x1f2 <delay_ms+0x1e>
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
}

void delay_ms(uint16_t x)
{
     1ee:	2a e5       	ldi	r18, 0x5A	; 90
     1f0:	f4 cf       	rjmp	.-24     	; 0x1da <delay_ms+0x6>
     1f2:	08 95       	ret

000001f4 <i2cSendByte>:
    while ((!(TWCR & (1<<TWINT))) && (i < 90))
		i++;
}

void i2cSendByte(unsigned char data)
{
     1f4:	cf 93       	push	r28
     1f6:	c8 2f       	mov	r28, r24
	delay_ms(1);
     1f8:	81 e0       	ldi	r24, 0x01	; 1
     1fa:	90 e0       	ldi	r25, 0x00	; 0
     1fc:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <delay_ms>
	//printf("sending 0x%x\n", data);
	WRITE_sda();
     200:	51 9a       	sbi	0x0a, 1	; 10
	// save data to the TWDR
	TWDR = data;
     202:	c0 93 bb 00 	sts	0x00BB, r28
	// begin send
	TWCR = (1<<TWINT)|(1<<TWEN);
     206:	84 e8       	ldi	r24, 0x84	; 132
     208:	80 93 bc 00 	sts	0x00BC, r24
}
     20c:	cf 91       	pop	r28
     20e:	08 95       	ret

00000210 <timer2_init>:
 * Logic: This function will create interrupt as per sample rate to play .wav file with 16 bit pwm in timer1.
 * Example Call: timer2_init();
 */
void timer2_init()
{
	TCNT2=0x00;
     210:	10 92 b2 00 	sts	0x00B2, r1
	TCCR2A=(1<<WGM21);                      //Timer 2 CTC Mode
     214:	82 e0       	ldi	r24, 0x02	; 2
     216:	80 93 b0 00 	sts	0x00B0, r24
	TIMSK2=(1<<OCIE2A);                     //Timer2 Interrupt on Compare Match A
     21a:	80 93 70 00 	sts	0x0070, r24
	OCR2A= sample_timer_data;               // this value is as per sample rate of .wav file;
     21e:	90 91 41 02 	lds	r25, 0x0241
     222:	90 93 b3 00 	sts	0x00B3, r25
	TCCR2B=(1<<CS21);                       // 8 bit prescale;
     226:	80 93 b1 00 	sts	0x00B1, r24
}
     22a:	08 95       	ret

0000022c <timer1_pwm_init>:
 * Output: None
 * Logic: This function will make 8 bit pwm channel to play speaker.
 * Example Call: timer1_pwm_init();
 */
void timer1_pwm_init(){
	TCNT1H=0x00;
     22c:	10 92 85 00 	sts	0x0085, r1
	TCNT1L=0x00;
     230:	10 92 84 00 	sts	0x0084, r1
	OCR1AH=0x00;
     234:	10 92 89 00 	sts	0x0089, r1
	OCR1AL=0x00;
     238:	10 92 88 00 	sts	0x0088, r1
	TCCR1A=(1<<WGM10)|(1<<COM1A1);
     23c:	81 e8       	ldi	r24, 0x81	; 129
     23e:	80 93 80 00 	sts	0x0080, r24
	TCCR1B=(1<<WGM12)|(1<<CS10);
     242:	89 e0       	ldi	r24, 0x09	; 9
     244:	80 93 81 00 	sts	0x0081, r24
}
     248:	08 95       	ret

0000024a <extract_headder>:
{
	int i;
	//uint16_t temp_sample=0, temp_sample2=0;
	for(i=24;i<28;i++)
	{
		sample_rate = sample_rate | (unsigned int)(buffer[i] << (8*(i-24)));
     24a:	40 91 98 04 	lds	r20, 0x0498
     24e:	50 e0       	ldi	r21, 0x00	; 0
     250:	e0 91 57 02 	lds	r30, 0x0257
     254:	f0 91 58 02 	lds	r31, 0x0258
     258:	4e 2b       	or	r20, r30
     25a:	5f 2b       	or	r21, r31
     25c:	70 91 99 04 	lds	r23, 0x0499
     260:	60 e0       	ldi	r22, 0x00	; 0
     262:	64 2b       	or	r22, r20
     264:	75 2b       	or	r23, r21
     266:	80 91 9a 04 	lds	r24, 0x049A
     26a:	58 2f       	mov	r21, r24
     26c:	55 27       	eor	r21, r21
     26e:	40 e0       	ldi	r20, 0x00	; 0
     270:	46 2b       	or	r20, r22
     272:	57 2b       	or	r21, r23
     274:	20 91 9b 04 	lds	r18, 0x049B
     278:	92 2f       	mov	r25, r18
     27a:	99 27       	eor	r25, r25
     27c:	80 e0       	ldi	r24, 0x00	; 0
     27e:	84 2b       	or	r24, r20
     280:	95 2b       	or	r25, r21
     282:	90 93 58 02 	sts	0x0258, r25
     286:	80 93 57 02 	sts	0x0257, r24
		
	}
	sample_timer_data = (1843200/sample_rate);                                                     //          ( F_CPU / 8(prescaler)) = 1843200 . this data is to be given to sample timer
     28a:	9c 01       	movw	r18, r24
     28c:	40 e0       	ldi	r20, 0x00	; 0
     28e:	50 e0       	ldi	r21, 0x00	; 0
     290:	60 e0       	ldi	r22, 0x00	; 0
     292:	70 e2       	ldi	r23, 0x20	; 32
     294:	8c e1       	ldi	r24, 0x1C	; 28
     296:	90 e0       	ldi	r25, 0x00	; 0
     298:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <__divmodsi4>
     29c:	20 93 41 02 	sts	0x0241, r18
	
	for(i=34;i<36;i++)
	{
		bits_per_sample = bits_per_sample | (buffer[i] << (8*(i-34)));
     2a0:	20 91 a2 04 	lds	r18, 0x04A2
     2a4:	30 e0       	ldi	r19, 0x00	; 0
     2a6:	40 91 55 02 	lds	r20, 0x0255
     2aa:	50 91 56 02 	lds	r21, 0x0256
     2ae:	24 2b       	or	r18, r20
     2b0:	35 2b       	or	r19, r21
     2b2:	90 91 a3 04 	lds	r25, 0x04A3
     2b6:	80 e0       	ldi	r24, 0x00	; 0
     2b8:	82 2b       	or	r24, r18
     2ba:	93 2b       	or	r25, r19
     2bc:	90 93 56 02 	sts	0x0256, r25
     2c0:	80 93 55 02 	sts	0x0255, r24
	}
	bytes_per_sample=bits_per_sample/8;
     2c4:	96 95       	lsr	r25
     2c6:	87 95       	ror	r24
     2c8:	96 95       	lsr	r25
     2ca:	87 95       	ror	r24
     2cc:	96 95       	lsr	r25
     2ce:	87 95       	ror	r24
     2d0:	80 93 52 02 	sts	0x0252, r24
	for(i=16;i<20;i++)
	{
		data_start = data_start | (buffer[i] << (8*(i-16)));
     2d4:	20 91 90 04 	lds	r18, 0x0490
     2d8:	30 e0       	ldi	r19, 0x00	; 0
     2da:	60 91 53 02 	lds	r22, 0x0253
     2de:	70 91 54 02 	lds	r23, 0x0254
     2e2:	26 2b       	or	r18, r22
     2e4:	37 2b       	or	r19, r23
     2e6:	50 91 91 04 	lds	r21, 0x0491
     2ea:	40 e0       	ldi	r20, 0x00	; 0
     2ec:	42 2b       	or	r20, r18
     2ee:	53 2b       	or	r21, r19
     2f0:	80 91 92 04 	lds	r24, 0x0492
     2f4:	38 2f       	mov	r19, r24
     2f6:	33 27       	eor	r19, r19
     2f8:	20 e0       	ldi	r18, 0x00	; 0
     2fa:	24 2b       	or	r18, r20
     2fc:	35 2b       	or	r19, r21
     2fe:	40 91 93 04 	lds	r20, 0x0493
     302:	94 2f       	mov	r25, r20
     304:	99 27       	eor	r25, r25
     306:	80 e0       	ldi	r24, 0x00	; 0
     308:	82 2b       	or	r24, r18
     30a:	93 2b       	or	r25, r19
	}
	data_start=data_start+28;
     30c:	4c 96       	adiw	r24, 0x1c	; 28
     30e:	90 93 54 02 	sts	0x0254, r25
     312:	80 93 53 02 	sts	0x0253, r24
	lcd_numeric_value(1,1,sample_rate,5);
	lcd_numeric_value(1,8,bits_per_sample,3);
	lcd_numeric_value(2,1,bytes_per_sample,3);
	lcd_numeric_value(2,8,data_start,3);
	_delay_ms(50);*/
}
     316:	08 95       	ret

00000318 <IRQ_interrupt_init>:
 * Logic: This function will initialize the external interrupt 4 for MPRsensor.
 * Example Call: IRQ_interrupt_init();
 */
void IRQ_interrupt_init(void) //      Making interrupt for IRQ pin from the mpr121 sensor
{
	EICRB=0x00;      //           making int4 interrupt response on low level
     318:	10 92 6a 00 	sts	0x006A, r1
	EIMSK=(1<<INT4);
     31c:	80 e1       	ldi	r24, 0x10	; 16
     31e:	8d bb       	out	0x1d, r24	; 29
}
     320:	08 95       	ret

00000322 <uart0_init>:
 * Logic: This function will initialize uart0 with baud rate -> 9600, char size -> 8 bit, parity -> disabled.
 * Example Call: uart0_init();
 */
void uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
     322:	e1 ec       	ldi	r30, 0xC1	; 193
     324:	f0 e0       	ldi	r31, 0x00	; 0
     326:	10 82       	st	Z, r1
	UCSR0A = 0x00;
     328:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C |= (1 << UCSZ01) | (1 << UCSZ00);// same as 0x06
     32c:	a2 ec       	ldi	r26, 0xC2	; 194
     32e:	b0 e0       	ldi	r27, 0x00	; 0
     330:	8c 91       	ld	r24, X
     332:	86 60       	ori	r24, 0x06	; 6
     334:	8c 93       	st	X, r24
	UBRR0L = 0x5F; //set baud rate lo
     336:	8f e5       	ldi	r24, 0x5F	; 95
     338:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate hi
     33c:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B |= (1 << RXEN0) | (1 << TXEN0);//same as 0x98
     340:	80 81       	ld	r24, Z
     342:	88 61       	ori	r24, 0x18	; 24
     344:	80 83       	st	Z, r24
}
     346:	08 95       	ret

00000348 <uart_tx>:
 * Example Call: uart_tx();
 */
void uart_tx(char data)
{
	// waiting to transmit
	while(!(UCSR0A & (1 << UDRE0)));
     348:	e0 ec       	ldi	r30, 0xC0	; 192
     34a:	f0 e0       	ldi	r31, 0x00	; 0
     34c:	90 81       	ld	r25, Z
     34e:	95 ff       	sbrs	r25, 5
     350:	fd cf       	rjmp	.-6      	; 0x34c <uart_tx+0x4>
	
	UDR0 = data;
     352:	80 93 c6 00 	sts	0x00C6, r24
}
     356:	08 95       	ret

00000358 <uart_tx_string>:
 * Output: None
 * Logic: send a string to usart0.
 * Example Call: uart_tx_string();
 */
void uart_tx_string(char *data)
{
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	ec 01       	movw	r28, r24
	while (*data != '\0')
     35e:	88 81       	ld	r24, Y
     360:	88 23       	and	r24, r24
     362:	31 f0       	breq	.+12     	; 0x370 <uart_tx_string+0x18>
 * Input: sting pointer to be sent
 * Output: None
 * Logic: send a string to usart0.
 * Example Call: uart_tx_string();
 */
void uart_tx_string(char *data)
     364:	21 96       	adiw	r28, 0x01	; 1
{
	while (*data != '\0')
	{
		uart_tx(*data);
     366:	0e 94 a4 01 	call	0x348	; 0x348 <uart_tx>
 * Logic: send a string to usart0.
 * Example Call: uart_tx_string();
 */
void uart_tx_string(char *data)
{
	while (*data != '\0')
     36a:	89 91       	ld	r24, Y+
     36c:	88 23       	and	r24, r24
     36e:	d9 f7       	brne	.-10     	; 0x366 <uart_tx_string+0xe>
	{
		uart_tx(*data);
		data++;
	}
}
     370:	df 91       	pop	r29
     372:	cf 91       	pop	r28
     374:	08 95       	ret

00000376 <mpr121_Read>:
 * Output: data in the input resister
 * Logic: This  will read the given resister data from the mpr121 sensor.
 * Example Call: mpr121_Read(0x00);
 */
char mpr121_Read(unsigned char address)
{
     376:	cf 93       	push	r28
     378:	c8 2f       	mov	r28, r24
	char data;
	
	i2cSendStart();
     37a:	0e 94 bd 00 	call	0x17a	; 0x17a <i2cSendStart>
	i2cWaitForComplete();
     37e:	0e 94 c6 00 	call	0x18c	; 0x18c <i2cWaitForComplete>
	
	i2cSendByte(((mpradd << 1) | 0x00));
     382:	80 91 39 02 	lds	r24, 0x0239
     386:	88 0f       	add	r24, r24
     388:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <i2cSendByte>
	i2cWaitForComplete();
     38c:	0e 94 c6 00 	call	0x18c	; 0x18c <i2cWaitForComplete>
	
	i2cSendByte(address);	// write register address
     390:	8c 2f       	mov	r24, r28
     392:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <i2cSendByte>
	i2cWaitForComplete();
     396:	0e 94 c6 00 	call	0x18c	; 0x18c <i2cWaitForComplete>
	
	i2cSendStart();
     39a:	0e 94 bd 00 	call	0x17a	; 0x17a <i2cSendStart>
	
	i2cSendByte(((mpradd << 1) | 0x01));
     39e:	80 91 39 02 	lds	r24, 0x0239
     3a2:	88 0f       	add	r24, r24
     3a4:	81 60       	ori	r24, 0x01	; 1
     3a6:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <i2cSendByte>
	i2cWaitForComplete();
     3aa:	0e 94 c6 00 	call	0x18c	; 0x18c <i2cWaitForComplete>
	i2cReceiveByte(TRUE);
     3ae:	8f ef       	ldi	r24, 0xFF	; 255
     3b0:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <i2cReceiveByte>
	i2cWaitForComplete();
     3b4:	0e 94 c6 00 	call	0x18c	; 0x18c <i2cWaitForComplete>
	
	data = i2cGetReceivedByte();	// Get MSB result
     3b8:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <i2cGetReceivedByte>
     3bc:	c8 2f       	mov	r28, r24
	i2cWaitForComplete();
     3be:	0e 94 c6 00 	call	0x18c	; 0x18c <i2cWaitForComplete>
	i2cSendStop();
     3c2:	0e 94 c2 00 	call	0x184	; 0x184 <i2cSendStop>
	
	cbi(TWCR, TWEN);	// Disable TWI
     3c6:	ec eb       	ldi	r30, 0xBC	; 188
     3c8:	f0 e0       	ldi	r31, 0x00	; 0
     3ca:	80 81       	ld	r24, Z
     3cc:	8b 7f       	andi	r24, 0xFB	; 251
     3ce:	80 83       	st	Z, r24
	sbi(TWCR, TWEN);	// Enable TWI
     3d0:	80 81       	ld	r24, Z
     3d2:	84 60       	ori	r24, 0x04	; 4
     3d4:	80 83       	st	Z, r24
	
	return data;
}
     3d6:	8c 2f       	mov	r24, r28
     3d8:	cf 91       	pop	r28
     3da:	08 95       	ret

000003dc <mpr121Write>:
 * Output: None
 * Logic: Function to write given data at the given address
 * Example Call: mpr121Write(0x00,0x00);
 */
void mpr121Write(unsigned char address, unsigned char data)
{
     3dc:	cf 93       	push	r28
     3de:	df 93       	push	r29
     3e0:	d8 2f       	mov	r29, r24
     3e2:	c6 2f       	mov	r28, r22
	i2cSendStart();
     3e4:	0e 94 bd 00 	call	0x17a	; 0x17a <i2cSendStart>
	i2cWaitForComplete();
     3e8:	0e 94 c6 00 	call	0x18c	; 0x18c <i2cWaitForComplete>
	i2cSendByte(((mpradd << 1) | 0x00));
     3ec:	80 91 39 02 	lds	r24, 0x0239
     3f0:	88 0f       	add	r24, r24
     3f2:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <i2cSendByte>
	i2cWaitForComplete();
     3f6:	0e 94 c6 00 	call	0x18c	; 0x18c <i2cWaitForComplete>
	i2cSendByte(address);
     3fa:	8d 2f       	mov	r24, r29
     3fc:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <i2cSendByte>
	i2cWaitForComplete();
     400:	0e 94 c6 00 	call	0x18c	; 0x18c <i2cWaitForComplete>
	i2cSendByte(data);
     404:	8c 2f       	mov	r24, r28
     406:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <i2cSendByte>
	i2cWaitForComplete();
     40a:	0e 94 c6 00 	call	0x18c	; 0x18c <i2cWaitForComplete>
	i2cSendStop();
     40e:	0e 94 c2 00 	call	0x184	; 0x184 <i2cSendStop>
	
}
     412:	df 91       	pop	r29
     414:	cf 91       	pop	r28
     416:	08 95       	ret

00000418 <classify_key_trumpet>:
 * Example Call: mpr121Write(0x00,0x00);
 */
char classify_key_trumpet(unsigned char trumpet_byte)
{
	unsigned char a, trumpet_key;
	a=trumpet_byte&0b00000111;
     418:	87 70       	andi	r24, 0x07	; 7
	switch(a)
     41a:	84 30       	cpi	r24, 0x04	; 4
     41c:	91 f0       	breq	.+36     	; 0x442 <classify_key_trumpet+0x2a>
     41e:	85 30       	cpi	r24, 0x05	; 5
     420:	38 f4       	brcc	.+14     	; 0x430 <classify_key_trumpet+0x18>
     422:	82 30       	cpi	r24, 0x02	; 2
     424:	d1 f0       	breq	.+52     	; 0x45a <classify_key_trumpet+0x42>
     426:	83 30       	cpi	r24, 0x03	; 3
     428:	70 f4       	brcc	.+28     	; 0x446 <classify_key_trumpet+0x2e>
     42a:	81 30       	cpi	r24, 0x01	; 1
     42c:	a1 f4       	brne	.+40     	; 0x456 <classify_key_trumpet+0x3e>
     42e:	07 c0       	rjmp	.+14     	; 0x43e <classify_key_trumpet+0x26>
     430:	86 30       	cpi	r24, 0x06	; 6
     432:	59 f0       	breq	.+22     	; 0x44a <classify_key_trumpet+0x32>
     434:	86 30       	cpi	r24, 0x06	; 6
     436:	58 f0       	brcs	.+22     	; 0x44e <classify_key_trumpet+0x36>
     438:	87 30       	cpi	r24, 0x07	; 7
     43a:	69 f4       	brne	.+26     	; 0x456 <classify_key_trumpet+0x3e>
     43c:	0a c0       	rjmp	.+20     	; 0x452 <classify_key_trumpet+0x3a>
	{
		case 0b00000001 :
		trumpet_key='C';
     43e:	83 e4       	ldi	r24, 0x43	; 67
     440:	08 95       	ret
		break;
		case 0b00000010 :
		trumpet_key='D';
		break;
		case 0b00000100 :
		trumpet_key='E';
     442:	85 e4       	ldi	r24, 0x45	; 69
		break;
     444:	08 95       	ret
		case 0b00000011 :
		trumpet_key='F';
     446:	86 e4       	ldi	r24, 0x46	; 70
		break;
     448:	08 95       	ret
		case 0b00000110 :
		trumpet_key='G';
     44a:	87 e4       	ldi	r24, 0x47	; 71
		break;
     44c:	08 95       	ret
		case 0b00000101 :
		trumpet_key='A';
     44e:	81 e4       	ldi	r24, 0x41	; 65
		break;
     450:	08 95       	ret
		case 0b00000111 :
		trumpet_key='B';
     452:	82 e4       	ldi	r24, 0x42	; 66
		break;
     454:	08 95       	ret
		default:
		trumpet_key='0';
     456:	80 e3       	ldi	r24, 0x30	; 48
     458:	08 95       	ret
	{
		case 0b00000001 :
		trumpet_key='C';
		break;
		case 0b00000010 :
		trumpet_key='D';
     45a:	84 e4       	ldi	r24, 0x44	; 68
		break;
		default:
		trumpet_key='0';
	}
	return(trumpet_key);
}
     45c:	08 95       	ret

0000045e <classify_key_piano>:
 * Output: char key is has been pressed
 * Logic: This function will take the status of MPR121 electrode and return the key which has been pressed.
 * Example Call: classify_key(status_mpr);
 */
char classify_key_piano(unsigned char status_mpr)
{
     45e:	27 e0       	ldi	r18, 0x07	; 7
     460:	30 e0       	ldi	r19, 0x00	; 0
	unsigned char i,j,count=0x00;
     462:	60 e0       	ldi	r22, 0x00	; 0
	for( i=0 ; i<8 ; i++)
	{
		if( (status_mpr & (1<<(7-i))) != 0 )
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	ac 01       	movw	r20, r24
     468:	02 2e       	mov	r0, r18
     46a:	02 c0       	rjmp	.+4      	; 0x470 <classify_key_piano+0x12>
     46c:	55 95       	asr	r21
     46e:	47 95       	ror	r20
     470:	0a 94       	dec	r0
     472:	e2 f7       	brpl	.-8      	; 0x46c <classify_key_piano+0xe>
     474:	40 ff       	sbrs	r20, 0
     476:	02 c0       	rjmp	.+4      	; 0x47c <classify_key_piano+0x1e>
		{
			// (7-i)th key of mpr is touched;
			j=7-i;
     478:	72 2f       	mov	r23, r18
			count=count+1;
     47a:	6f 5f       	subi	r22, 0xFF	; 255
     47c:	21 50       	subi	r18, 0x01	; 1
     47e:	30 40       	sbci	r19, 0x00	; 0
 * Example Call: classify_key(status_mpr);
 */
char classify_key_piano(unsigned char status_mpr)
{
	unsigned char i,j,count=0x00;
	for( i=0 ; i<8 ; i++)
     480:	4f ef       	ldi	r20, 0xFF	; 255
     482:	2f 3f       	cpi	r18, 0xFF	; 255
     484:	34 07       	cpc	r19, r20
     486:	79 f7       	brne	.-34     	; 0x466 <classify_key_piano+0x8>
			j=7-i;
			count=count+1;
			//return keys[7-i];
		}
	}
	if(count==1){
     488:	61 30       	cpi	r22, 0x01	; 1
     48a:	31 f4       	brne	.+12     	; 0x498 <classify_key_piano+0x3a>
		return keys[j];
     48c:	e1 e3       	ldi	r30, 0x31	; 49
     48e:	f2 e0       	ldi	r31, 0x02	; 2
     490:	e7 0f       	add	r30, r23
     492:	f1 1d       	adc	r31, r1
     494:	80 81       	ld	r24, Z
     496:	08 95       	ret
	}
	else{
		//lcd_clear();
		//lcd_string(1, 1, "multiple key");
		return '0';
     498:	80 e3       	ldi	r24, 0x30	; 48
	}
}
     49a:	08 95       	ret

0000049c <mpr121_initialise>:
 * Logic: Function to initialize the mpr121 touch sensor.
 * Example Call: mpr121_initialise();
 */
void mpr121_initialise(void)     // initializing to read the touch status of the mpr121 sensor.
{
	mpr121Write(0x2B, 0x01);
     49c:	8b e2       	ldi	r24, 0x2B	; 43
     49e:	61 e0       	ldi	r22, 0x01	; 1
     4a0:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x2C, 0x01);
     4a4:	8c e2       	ldi	r24, 0x2C	; 44
     4a6:	61 e0       	ldi	r22, 0x01	; 1
     4a8:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x2D, 0x00);
     4ac:	8d e2       	ldi	r24, 0x2D	; 45
     4ae:	60 e0       	ldi	r22, 0x00	; 0
     4b0:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x2E, 0x00);
     4b4:	8e e2       	ldi	r24, 0x2E	; 46
     4b6:	60 e0       	ldi	r22, 0x00	; 0
     4b8:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>

	mpr121Write(0x2F, 0x01);
     4bc:	8f e2       	ldi	r24, 0x2F	; 47
     4be:	61 e0       	ldi	r22, 0x01	; 1
     4c0:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x30, 0x01);
     4c4:	80 e3       	ldi	r24, 0x30	; 48
     4c6:	61 e0       	ldi	r22, 0x01	; 1
     4c8:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x31, 0xFF);
     4cc:	81 e3       	ldi	r24, 0x31	; 49
     4ce:	6f ef       	ldi	r22, 0xFF	; 255
     4d0:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x32, 0x02);
     4d4:	82 e3       	ldi	r24, 0x32	; 50
     4d6:	62 e0       	ldi	r22, 0x02	; 2
     4d8:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	
	// This group sets touch and release thresholds for each electrode
	mpr121Write(0x41, TOU_THRESH);
     4dc:	81 e4       	ldi	r24, 0x41	; 65
     4de:	6f e0       	ldi	r22, 0x0F	; 15
     4e0:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x42, REL_THRESH);
     4e4:	82 e4       	ldi	r24, 0x42	; 66
     4e6:	6a e0       	ldi	r22, 0x0A	; 10
     4e8:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x43, TOU_THRESH);
     4ec:	83 e4       	ldi	r24, 0x43	; 67
     4ee:	6f e0       	ldi	r22, 0x0F	; 15
     4f0:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x44, REL_THRESH);
     4f4:	84 e4       	ldi	r24, 0x44	; 68
     4f6:	6a e0       	ldi	r22, 0x0A	; 10
     4f8:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x45, TOU_THRESH);
     4fc:	85 e4       	ldi	r24, 0x45	; 69
     4fe:	6f e0       	ldi	r22, 0x0F	; 15
     500:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x46, REL_THRESH);
     504:	86 e4       	ldi	r24, 0x46	; 70
     506:	6a e0       	ldi	r22, 0x0A	; 10
     508:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x47, TOU_THRESH);
     50c:	87 e4       	ldi	r24, 0x47	; 71
     50e:	6f e0       	ldi	r22, 0x0F	; 15
     510:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x48, REL_THRESH);
     514:	88 e4       	ldi	r24, 0x48	; 72
     516:	6a e0       	ldi	r22, 0x0A	; 10
     518:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x49, TOU_THRESH);
     51c:	89 e4       	ldi	r24, 0x49	; 73
     51e:	6f e0       	ldi	r22, 0x0F	; 15
     520:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x4A, REL_THRESH);
     524:	8a e4       	ldi	r24, 0x4A	; 74
     526:	6a e0       	ldi	r22, 0x0A	; 10
     528:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x4B, TOU_THRESH);
     52c:	8b e4       	ldi	r24, 0x4B	; 75
     52e:	6f e0       	ldi	r22, 0x0F	; 15
     530:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x4C, REL_THRESH);
     534:	8c e4       	ldi	r24, 0x4C	; 76
     536:	6a e0       	ldi	r22, 0x0A	; 10
     538:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x4D, TOU_THRESH);
     53c:	8d e4       	ldi	r24, 0x4D	; 77
     53e:	6f e0       	ldi	r22, 0x0F	; 15
     540:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x4E, REL_THRESH);
     544:	8e e4       	ldi	r24, 0x4E	; 78
     546:	6a e0       	ldi	r22, 0x0A	; 10
     548:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x4F, TOU_THRESH);
     54c:	8f e4       	ldi	r24, 0x4F	; 79
     54e:	6f e0       	ldi	r22, 0x0F	; 15
     550:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x50, REL_THRESH);
     554:	80 e5       	ldi	r24, 0x50	; 80
     556:	6a e0       	ldi	r22, 0x0A	; 10
     558:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	
	mpr121Write(0x51, TOU_THRESH);
     55c:	81 e5       	ldi	r24, 0x51	; 81
     55e:	6f e0       	ldi	r22, 0x0F	; 15
     560:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x52, REL_THRESH);
     564:	82 e5       	ldi	r24, 0x52	; 82
     566:	6a e0       	ldi	r22, 0x0A	; 10
     568:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x53, TOU_THRESH);
     56c:	83 e5       	ldi	r24, 0x53	; 83
     56e:	6f e0       	ldi	r22, 0x0F	; 15
     570:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x54, REL_THRESH);
     574:	84 e5       	ldi	r24, 0x54	; 84
     576:	6a e0       	ldi	r22, 0x0A	; 10
     578:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x55, TOU_THRESH);
     57c:	85 e5       	ldi	r24, 0x55	; 85
     57e:	6f e0       	ldi	r22, 0x0F	; 15
     580:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	mpr121Write(0x56, REL_THRESH);
     584:	86 e5       	ldi	r24, 0x56	; 86
     586:	6a e0       	ldi	r22, 0x0A	; 10
     588:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>

	
	mpr121Write(0x5D, 0x04);
     58c:	8d e5       	ldi	r24, 0x5D	; 93
     58e:	64 e0       	ldi	r22, 0x04	; 4
     590:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	
	mpr121Write(0x5E, 0b10001011);   // start run mode for first 11 electrodes
     594:	8e e5       	ldi	r24, 0x5E	; 94
     596:	6b e8       	ldi	r22, 0x8B	; 139
     598:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mpr121Write>
	
}
     59c:	08 95       	ret

0000059e <get_raw_values>:
 */
void get_raw_values() {
	
	char key;
	
	status_mpr = mpr121_Read(0x00);
     59e:	80 e0       	ldi	r24, 0x00	; 0
     5a0:	0e 94 bb 01 	call	0x376	; 0x376 <mpr121_Read>
     5a4:	80 93 40 02 	sts	0x0240, r24
	status_mpr_trumpet = mpr121_Read(0x01);
     5a8:	81 e0       	ldi	r24, 0x01	; 1
     5aa:	0e 94 bb 01 	call	0x376	; 0x376 <mpr121_Read>
     5ae:	80 93 3f 02 	sts	0x023F, r24
	
	if(status_mpr!=0)
     5b2:	90 91 40 02 	lds	r25, 0x0240
     5b6:	99 23       	and	r25, r25
     5b8:	a1 f0       	breq	.+40     	; 0x5e2 <get_raw_values+0x44>
	{
		TIMSK2=0x00;            // stop whatever is playing
     5ba:	10 92 70 00 	sts	0x0070, r1
		TCCR1B = 0x00;
     5be:	10 92 81 00 	sts	0x0081, r1
		
		key = classify_key_piano(status_mpr);
     5c2:	89 2f       	mov	r24, r25
     5c4:	0e 94 2f 02 	call	0x45e	; 0x45e <classify_key_piano>
		if(key!='0'){
     5c8:	80 33       	cpi	r24, 0x30	; 48
     5ca:	41 f0       	breq	.+16     	; 0x5dc <get_raw_values+0x3e>
			
			current_key = key;
     5cc:	80 93 30 02 	sts	0x0230, r24
			instrument = 0x01;
     5d0:	91 e0       	ldi	r25, 0x01	; 1
     5d2:	90 93 3d 02 	sts	0x023D, r25
			
			read_current_file(current_key);              // function to read and play the required file.
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	0e 94 dd 03 	call	0x7ba	; 0x7ba <read_current_file>
		}
		else{
			//lcd_string(2, 1, "ERROR");
		}
		status_mpr=0x00;
     5dc:	10 92 40 02 	sts	0x0240, r1
     5e0:	08 95       	ret
	}
	else if (status_mpr_trumpet !=0 )
     5e2:	88 23       	and	r24, r24
     5e4:	09 f1       	breq	.+66     	; 0x628 <get_raw_values+0x8a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     5e6:	8f ef       	ldi	r24, 0xFF	; 255
     5e8:	9f ef       	ldi	r25, 0xFF	; 255
     5ea:	a8 e0       	ldi	r26, 0x08	; 8
     5ec:	81 50       	subi	r24, 0x01	; 1
     5ee:	90 40       	sbci	r25, 0x00	; 0
     5f0:	a0 40       	sbci	r26, 0x00	; 0
     5f2:	e1 f7       	brne	.-8      	; 0x5ec <get_raw_values+0x4e>
     5f4:	00 c0       	rjmp	.+0      	; 0x5f6 <get_raw_values+0x58>
     5f6:	00 00       	nop
	{
		/*lcd_clear();
		lcd_wr_char(1, 1, key);*/
		_delay_ms(200);
		status_mpr_trumpet = mpr121_Read(0x01);            // read once more with 200 ms delay and update the status.(to avoid the error due to different response time in servo)
     5f8:	81 e0       	ldi	r24, 0x01	; 1
     5fa:	0e 94 bb 01 	call	0x376	; 0x376 <mpr121_Read>
     5fe:	80 93 3f 02 	sts	0x023F, r24
		
		
		if(status_mpr_trumpet != 0)
     602:	88 23       	and	r24, r24
     604:	89 f0       	breq	.+34     	; 0x628 <get_raw_values+0x8a>
		{
			TIMSK2=0x00;            // stop whatever is playing
     606:	10 92 70 00 	sts	0x0070, r1
			TCCR1B = 0x00;
     60a:	10 92 81 00 	sts	0x0081, r1
			
			key = classify_key_trumpet(status_mpr_trumpet);
     60e:	0e 94 0c 02 	call	0x418	; 0x418 <classify_key_trumpet>
		
		    if(key!='0')
     612:	80 33       	cpi	r24, 0x30	; 48
     614:	39 f0       	breq	.+14     	; 0x624 <get_raw_values+0x86>
			{
				
				current_key = key;
     616:	80 93 30 02 	sts	0x0230, r24
				instrument = 0x00;
     61a:	10 92 3d 02 	sts	0x023D, r1
			
				read_current_file(current_key);                         // function to read and play the required file.
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	0e 94 dd 03 	call	0x7ba	; 0x7ba <read_current_file>
		    }
		    else
			{
				//lcd_string(2, 1, "INVALID");
		    }
		    status_mpr_trumpet=0x00;
     624:	10 92 3f 02 	sts	0x023F, r1
     628:	08 95       	ret

0000062a <boot_switch_pin_config>:
 * Logic: to give internal pull-up in boot button
 * Example Call: boot_switch_pin_config();
 */
void boot_switch_pin_config()
{
	DDRD  = DDRD & 0xBF;		// set PD.6 as input
     62a:	56 98       	cbi	0x0a, 6	; 10
	PORTD = PORTD | 0x40;		// set PD.6 HIGH to enable the internal pull-up
     62c:	5e 9a       	sbi	0x0b, 6	; 11
}
     62e:	08 95       	ret

00000630 <initialise_mpr_pin>:
 * Logic: to initialize the pin configuration to use mpe through I2C protocol
 * Example Call: initialise_mpr_pin();
 */
void initialise_mpr_pin(void)
{
	DDRE|=0b00000000;//           Pull-up on int4 pin for IRQ pin from the sensor.
     630:	8d b1       	in	r24, 0x0d	; 13
     632:	8d b9       	out	0x0d, r24	; 13
	PORTE|=0b00010000;
     634:	74 9a       	sbi	0x0e, 4	; 14
	
	DDRD|=0x00;//                 Pull-up for the SDA and SCL line.
     636:	8a b1       	in	r24, 0x0a	; 10
     638:	8a b9       	out	0x0a, r24	; 10
	PORTD|=0b00000011;
     63a:	8b b1       	in	r24, 0x0b	; 11
     63c:	83 60       	ori	r24, 0x03	; 3
     63e:	8b b9       	out	0x0b, r24	; 11
}
     640:	08 95       	ret

00000642 <initialise_device>:
	//lcd_init();
	//lcd_string(1,1, "LCD INIT.");
	//_delay_ms(200);
	
	// mpr121 initialization
	initialise_mpr_pin();
     642:	0e 94 18 03 	call	0x630	; 0x630 <initialise_mpr_pin>
	sei();
     646:	78 94       	sei
	i2cInit();
     648:	0e 94 b3 00 	call	0x166	; 0x166 <i2cInit>
	mpr121_initialise();
     64c:	0e 94 4e 02 	call	0x49c	; 0x49c <mpr121_initialise>
     650:	8f ef       	ldi	r24, 0xFF	; 255
     652:	9f e3       	ldi	r25, 0x3F	; 63
     654:	a2 e0       	ldi	r26, 0x02	; 2
     656:	81 50       	subi	r24, 0x01	; 1
     658:	90 40       	sbci	r25, 0x00	; 0
     65a:	a0 40       	sbci	r26, 0x00	; 0
     65c:	e1 f7       	brne	.-8      	; 0x656 <initialise_device+0x14>
     65e:	00 c0       	rjmp	.+0      	; 0x660 <initialise_device+0x1e>
     660:	00 00       	nop
	//lcd_string(1, 1, "MPR START");
	_delay_ms(50);
	
	// SD card and FAT32 initialization
	
	DDRB|=0b00100000;
     662:	25 9a       	sbi	0x04, 5	; 4
	PORTB&=0b11011111;
     664:	2d 98       	cbi	0x05, 5	; 5

	if (sd_card_init())
     666:	0e 94 a1 0c 	call	0x1942	; 0x1942 <sd_card_init>
     66a:	88 23       	and	r24, r24
     66c:	71 f0       	breq	.+28     	; 0x68a <initialise_device+0x48>
     66e:	8f ef       	ldi	r24, 0xFF	; 255
     670:	9f e3       	ldi	r25, 0x3F	; 63
     672:	a2 e0       	ldi	r26, 0x02	; 2
     674:	81 50       	subi	r24, 0x01	; 1
     676:	90 40       	sbci	r25, 0x00	; 0
     678:	a0 40       	sbci	r26, 0x00	; 0
     67a:	e1 f7       	brne	.-8      	; 0x674 <initialise_device+0x32>
     67c:	00 c0       	rjmp	.+0      	; 0x67e <initialise_device+0x3c>
     67e:	00 00       	nop
	{
		//lcd_clear();
		//lcd_string(1,1,"CARD NOT FOUND");
		while(1);
	}
	if (get_boot_sector_data())
     680:	0e 94 f5 06 	call	0xdea	; 0xdea <get_boot_sector_data>
     684:	88 23       	and	r24, r24
     686:	11 f4       	brne	.+4      	; 0x68c <initialise_device+0x4a>
     688:	0b c0       	rjmp	.+22     	; 0x6a0 <initialise_device+0x5e>
     68a:	ff cf       	rjmp	.-2      	; 0x68a <initialise_device+0x48>
     68c:	8f ef       	ldi	r24, 0xFF	; 255
     68e:	9f e3       	ldi	r25, 0x3F	; 63
     690:	a2 e0       	ldi	r26, 0x02	; 2
     692:	81 50       	subi	r24, 0x01	; 1
     694:	90 40       	sbci	r25, 0x00	; 0
     696:	a0 40       	sbci	r26, 0x00	; 0
     698:	e1 f7       	brne	.-8      	; 0x692 <initialise_device+0x50>
     69a:	00 c0       	rjmp	.+0      	; 0x69c <initialise_device+0x5a>
     69c:	00 00       	nop
	{
		//lcd_clear();
		//lcd_string(1,1,"FAT32 ERROR");
		while(1);
	}
}
     69e:	08 95       	ret
     6a0:	ff cf       	rjmp	.-2      	; 0x6a0 <initialise_device+0x5e>

000006a2 <concatenate_filename_send_to_python>:
 * Logic: This function will make the file name by concatenating current_key and the configuration_table given and
          will save the same in file_name string. And will send the file_name to python through USB.
 * Example Call: concatenate_filename_send_to_python('A');
 */
void concatenate_filename_send_to_python(char key)
{
     6a2:	1f 93       	push	r17
     6a4:	cf 93       	push	r28
     6a6:	df 93       	push	r29
     6a8:	c8 2f       	mov	r28, r24
	
	//file_name=key+(sharp note)+(octave)+(_)+(Pia)/(Tru)+(.wav)
	
	
	unsigned char index=0;
	uart_tx(key);
     6aa:	0e 94 a4 01 	call	0x348	; 0x348 <uart_tx>
	file_name[index]=key;
     6ae:	c0 93 42 02 	sts	0x0242, r28
	index = index+1;
	if (configuration_table[onset_counter][1] == 'Y')
     6b2:	e0 91 3c 02 	lds	r30, 0x023C
     6b6:	f0 e0       	ldi	r31, 0x00	; 0
     6b8:	ee 0f       	add	r30, r30
     6ba:	ff 1f       	adc	r31, r31
     6bc:	e4 5e       	subi	r30, 0xE4	; 228
     6be:	fd 4f       	sbci	r31, 0xFD	; 253
     6c0:	81 81       	ldd	r24, Z+1	; 0x01
     6c2:	89 35       	cpi	r24, 0x59	; 89
     6c4:	39 f4       	brne	.+14     	; 0x6d4 <concatenate_filename_send_to_python+0x32>
	{
		file_name[index] = '#';
     6c6:	83 e2       	ldi	r24, 0x23	; 35
     6c8:	80 93 43 02 	sts	0x0243, r24
		index = index+1;
		uart_tx('#');
     6cc:	0e 94 a4 01 	call	0x348	; 0x348 <uart_tx>
	file_name[index]=key;
	index = index+1;
	if (configuration_table[onset_counter][1] == 'Y')
	{
		file_name[index] = '#';
		index = index+1;
     6d0:	12 e0       	ldi	r17, 0x02	; 2
     6d2:	01 c0       	rjmp	.+2      	; 0x6d6 <concatenate_filename_send_to_python+0x34>
	
	
	unsigned char index=0;
	uart_tx(key);
	file_name[index]=key;
	index = index+1;
     6d4:	11 e0       	ldi	r17, 0x01	; 1
	{
		file_name[index] = '#';
		index = index+1;
		uart_tx('#');
	}
	file_name[index]=configuration_table[onset_counter][0];
     6d6:	e0 91 3c 02 	lds	r30, 0x023C
     6da:	f0 e0       	ldi	r31, 0x00	; 0
     6dc:	ee 0f       	add	r30, r30
     6de:	ff 1f       	adc	r31, r31
     6e0:	e4 5e       	subi	r30, 0xE4	; 228
     6e2:	fd 4f       	sbci	r31, 0xFD	; 253
     6e4:	80 81       	ld	r24, Z
     6e6:	c2 e4       	ldi	r28, 0x42	; 66
     6e8:	d2 e0       	ldi	r29, 0x02	; 2
     6ea:	fe 01       	movw	r30, r28
     6ec:	e1 0f       	add	r30, r17
     6ee:	f1 1d       	adc	r31, r1
     6f0:	80 83       	st	Z, r24
	uart_tx(configuration_table[onset_counter][0]);
     6f2:	0e 94 a4 01 	call	0x348	; 0x348 <uart_tx>
	uart_tx_string("\n");
     6f6:	80 e0       	ldi	r24, 0x00	; 0
     6f8:	92 e0       	ldi	r25, 0x02	; 2
     6fa:	0e 94 ac 01 	call	0x358	; 0x358 <uart_tx_string>
	index = index+1;
     6fe:	81 2f       	mov	r24, r17
     700:	8f 5f       	subi	r24, 0xFF	; 255
	file_name[index]='_';
     702:	c8 0f       	add	r28, r24
     704:	d1 1d       	adc	r29, r1
     706:	8f e5       	ldi	r24, 0x5F	; 95
     708:	88 83       	st	Y, r24
	index = index+1;
     70a:	21 2f       	mov	r18, r17
     70c:	2e 5f       	subi	r18, 0xFE	; 254
	
	if(instrument == 0x01)
     70e:	80 91 3d 02 	lds	r24, 0x023D
     712:	81 30       	cpi	r24, 0x01	; 1
     714:	b9 f4       	brne	.+46     	; 0x744 <concatenate_filename_send_to_python+0xa2>
	{
		file_name[index] = 'P';
     716:	82 e4       	ldi	r24, 0x42	; 66
     718:	92 e0       	ldi	r25, 0x02	; 2
     71a:	fc 01       	movw	r30, r24
     71c:	e2 0f       	add	r30, r18
     71e:	f1 1d       	adc	r31, r1
     720:	20 e5       	ldi	r18, 0x50	; 80
     722:	20 83       	st	Z, r18
		index = index+1;
     724:	21 2f       	mov	r18, r17
     726:	2d 5f       	subi	r18, 0xFD	; 253
		file_name[index] = 'i';
     728:	fc 01       	movw	r30, r24
     72a:	e2 0f       	add	r30, r18
     72c:	f1 1d       	adc	r31, r1
     72e:	29 e6       	ldi	r18, 0x69	; 105
     730:	20 83       	st	Z, r18
		index = index+1;
     732:	21 2f       	mov	r18, r17
     734:	2c 5f       	subi	r18, 0xFC	; 252
		file_name[index] = 'a';
     736:	82 0f       	add	r24, r18
     738:	91 1d       	adc	r25, r1
     73a:	21 e6       	ldi	r18, 0x61	; 97
     73c:	fc 01       	movw	r30, r24
     73e:	20 83       	st	Z, r18
		index = index+1;
     740:	1b 5f       	subi	r17, 0xFB	; 251
     742:	16 c0       	rjmp	.+44     	; 0x770 <concatenate_filename_send_to_python+0xce>
	}
	else
	{
		file_name[index] = 'T';
     744:	82 e4       	ldi	r24, 0x42	; 66
     746:	92 e0       	ldi	r25, 0x02	; 2
     748:	fc 01       	movw	r30, r24
     74a:	e2 0f       	add	r30, r18
     74c:	f1 1d       	adc	r31, r1
     74e:	24 e5       	ldi	r18, 0x54	; 84
     750:	20 83       	st	Z, r18
		index = index+1;
     752:	21 2f       	mov	r18, r17
     754:	2d 5f       	subi	r18, 0xFD	; 253
		file_name[index] = 'r';
     756:	fc 01       	movw	r30, r24
     758:	e2 0f       	add	r30, r18
     75a:	f1 1d       	adc	r31, r1
     75c:	22 e7       	ldi	r18, 0x72	; 114
     75e:	20 83       	st	Z, r18
		index = index+1;
     760:	21 2f       	mov	r18, r17
     762:	2c 5f       	subi	r18, 0xFC	; 252
		file_name[index] = 'u';
     764:	82 0f       	add	r24, r18
     766:	91 1d       	adc	r25, r1
     768:	25 e7       	ldi	r18, 0x75	; 117
     76a:	fc 01       	movw	r30, r24
     76c:	20 83       	st	Z, r18
		index = index+1;
     76e:	1b 5f       	subi	r17, 0xFB	; 251
	}
	
	file_name[index] = '.';
     770:	82 e4       	ldi	r24, 0x42	; 66
     772:	92 e0       	ldi	r25, 0x02	; 2
     774:	fc 01       	movw	r30, r24
     776:	e1 0f       	add	r30, r17
     778:	f1 1d       	adc	r31, r1
     77a:	2e e2       	ldi	r18, 0x2E	; 46
     77c:	20 83       	st	Z, r18
	index = index+1;
     77e:	21 2f       	mov	r18, r17
     780:	2f 5f       	subi	r18, 0xFF	; 255
	file_name[index] = 'w';
     782:	fc 01       	movw	r30, r24
     784:	e2 0f       	add	r30, r18
     786:	f1 1d       	adc	r31, r1
     788:	27 e7       	ldi	r18, 0x77	; 119
     78a:	20 83       	st	Z, r18
	index = index+1;
     78c:	21 2f       	mov	r18, r17
     78e:	2e 5f       	subi	r18, 0xFE	; 254
	file_name[index] = 'a';
     790:	fc 01       	movw	r30, r24
     792:	e2 0f       	add	r30, r18
     794:	f1 1d       	adc	r31, r1
     796:	21 e6       	ldi	r18, 0x61	; 97
     798:	20 83       	st	Z, r18
	index = index+1;
     79a:	21 2f       	mov	r18, r17
     79c:	2d 5f       	subi	r18, 0xFD	; 253
	file_name[index] = 'v';
     79e:	fc 01       	movw	r30, r24
     7a0:	e2 0f       	add	r30, r18
     7a2:	f1 1d       	adc	r31, r1
     7a4:	26 e7       	ldi	r18, 0x76	; 118
     7a6:	20 83       	st	Z, r18
	index = index+1;
     7a8:	1c 5f       	subi	r17, 0xFC	; 252
	file_name[index] = '\0';
     7aa:	81 0f       	add	r24, r17
     7ac:	91 1d       	adc	r25, r1
     7ae:	fc 01       	movw	r30, r24
     7b0:	10 82       	st	Z, r1
	
}
     7b2:	df 91       	pop	r29
     7b4:	cf 91       	pop	r28
     7b6:	1f 91       	pop	r17
     7b8:	08 95       	ret

000007ba <read_current_file>:
 * Logic: This function will call concatenate function and then the read the respective file from sd card and then play
          this file in speaker.
 * Example Call: read_current_file(current_key);
 */
void read_current_file(char key)
{
     7ba:	2f 92       	push	r2
     7bc:	3f 92       	push	r3
     7be:	4f 92       	push	r4
     7c0:	5f 92       	push	r5
     7c2:	6f 92       	push	r6
     7c4:	7f 92       	push	r7
     7c6:	8f 92       	push	r8
     7c8:	9f 92       	push	r9
     7ca:	af 92       	push	r10
     7cc:	bf 92       	push	r11
     7ce:	cf 92       	push	r12
     7d0:	df 92       	push	r13
     7d2:	ef 92       	push	r14
     7d4:	ff 92       	push	r15
     7d6:	0f 93       	push	r16
     7d8:	1f 93       	push	r17
     7da:	cf 93       	push	r28
     7dc:	df 93       	push	r29
     7de:	cd b7       	in	r28, 0x3d	; 61
     7e0:	de b7       	in	r29, 0x3e	; 62
     7e2:	62 97       	sbiw	r28, 0x12	; 18
     7e4:	0f b6       	in	r0, 0x3f	; 63
     7e6:	f8 94       	cli
     7e8:	de bf       	out	0x3e, r29	; 62
     7ea:	0f be       	out	0x3f, r0	; 63
     7ec:	cd bf       	out	0x3d, r28	; 61
     7ee:	c8 2e       	mov	r12, r24
	unsigned long i=0,pos=0,j=0,cur=0x00, no_of_read=0x00;
	uint16_t temp_sample=0;
	
	if (key == '1')
     7f0:	21 e3       	ldi	r18, 0x31	; 49
     7f2:	82 17       	cp	r24, r18
     7f4:	89 f4       	brne	.+34     	; 0x818 <read_current_file+0x5e>
	{
		cli();                              // clear global interrupt as task is almost done
     7f6:	f8 94       	cli
		uart_tx_string("$");                // send end condition to python    
     7f8:	82 e0       	ldi	r24, 0x02	; 2
     7fa:	92 e0       	ldi	r25, 0x02	; 2
     7fc:	0e 94 ac 01 	call	0x358	; 0x358 <uart_tx_string>
		uart_tx_string("\n");
     800:	80 e0       	ldi	r24, 0x00	; 0
     802:	92 e0       	ldi	r25, 0x02	; 2
     804:	0e 94 ac 01 	call	0x358	; 0x358 <uart_tx_string>
		if (get_file_info(READ,"end.wav"))
     808:	81 e0       	ldi	r24, 0x01	; 1
     80a:	64 e0       	ldi	r22, 0x04	; 4
     80c:	72 e0       	ldi	r23, 0x02	; 2
     80e:	0e 94 0b 0a 	call	0x1416	; 0x1416 <get_file_info>
     812:	88 23       	and	r24, r24
     814:	31 f5       	brne	.+76     	; 0x862 <read_current_file+0xa8>
     816:	ff cf       	rjmp	.-2      	; 0x816 <read_current_file+0x5c>
			while(1);
		}
	}
	else
	{
		if(instrument == 0x01)
     818:	80 91 3d 02 	lds	r24, 0x023D
     81c:	81 30       	cpi	r24, 0x01	; 1
     81e:	49 f4       	brne	.+18     	; 0x832 <read_current_file+0x78>
		{
			uart_tx_string("Piano");
     820:	8c e0       	ldi	r24, 0x0C	; 12
     822:	92 e0       	ldi	r25, 0x02	; 2
     824:	0e 94 ac 01 	call	0x358	; 0x358 <uart_tx_string>
			uart_tx_string("\n");
     828:	80 e0       	ldi	r24, 0x00	; 0
     82a:	92 e0       	ldi	r25, 0x02	; 2
     82c:	0e 94 ac 01 	call	0x358	; 0x358 <uart_tx_string>
     830:	08 c0       	rjmp	.+16     	; 0x842 <read_current_file+0x88>
		}
		else
		{
			uart_tx_string("Trumpet");
     832:	82 e1       	ldi	r24, 0x12	; 18
     834:	92 e0       	ldi	r25, 0x02	; 2
     836:	0e 94 ac 01 	call	0x358	; 0x358 <uart_tx_string>
			uart_tx_string("\n");
     83a:	80 e0       	ldi	r24, 0x00	; 0
     83c:	92 e0       	ldi	r25, 0x02	; 2
     83e:	0e 94 ac 01 	call	0x358	; 0x358 <uart_tx_string>
		}
		concatenate_filename_send_to_python(key);
     842:	8c 2d       	mov	r24, r12
     844:	0e 94 51 03 	call	0x6a2	; 0x6a2 <concatenate_filename_send_to_python>
		onset_counter = onset_counter+1;
     848:	80 91 3c 02 	lds	r24, 0x023C
     84c:	8f 5f       	subi	r24, 0xFF	; 255
     84e:	80 93 3c 02 	sts	0x023C, r24
		
		if (get_file_info(READ,file_name))
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	62 e4       	ldi	r22, 0x42	; 66
     856:	72 e0       	ldi	r23, 0x02	; 2
     858:	0e 94 0b 0a 	call	0x1416	; 0x1416 <get_file_info>
     85c:	88 23       	and	r24, r24
     85e:	09 f4       	brne	.+2      	; 0x862 <read_current_file+0xa8>
     860:	ff cf       	rjmp	.-2      	; 0x860 <read_current_file+0xa6>
			while(1);
		}
	}
			
	
	curr_cluster=first_cluster;
     862:	80 91 61 02 	lds	r24, 0x0261
     866:	90 91 62 02 	lds	r25, 0x0262
     86a:	a0 91 63 02 	lds	r26, 0x0263
     86e:	b0 91 64 02 	lds	r27, 0x0264
     872:	80 93 65 04 	sts	0x0465, r24
     876:	90 93 66 04 	sts	0x0466, r25
     87a:	a0 93 67 04 	sts	0x0467, r26
     87e:	b0 93 68 04 	sts	0x0468, r27
	
	SPCR = (1 << SPE) | (1 << MSTR)| (1 << SPR0);            // increase the speed of SPI to ensure fast response
     882:	81 e5       	ldi	r24, 0x51	; 81
     884:	8c bd       	out	0x2c, r24	; 44
          this file in speaker.
 * Example Call: read_current_file(current_key);
 */
void read_current_file(char key)
{
	unsigned long i=0,pos=0,j=0,cur=0x00, no_of_read=0x00;
     886:	1d 82       	std	Y+5, r1	; 0x05
     888:	1e 82       	std	Y+6, r1	; 0x06
     88a:	1f 82       	std	Y+7, r1	; 0x07
     88c:	18 86       	std	Y+8, r1	; 0x08
     88e:	88 24       	eor	r8, r8
     890:	99 24       	eor	r9, r9
     892:	54 01       	movw	r10, r8
     894:	19 82       	std	Y+1, r1	; 0x01
     896:	1a 82       	std	Y+2, r1	; 0x02
     898:	1b 82       	std	Y+3, r1	; 0x03
     89a:	1c 82       	std	Y+4, r1	; 0x04
 * Output: None
 * Logic: This function will call concatenate function and then the read the respective file from sd card and then play
          this file in speaker.
 * Example Call: read_current_file(current_key);
 */
void read_current_file(char key)
     89c:	0f 2e       	mov	r0, r31
     89e:	f1 e8       	ldi	r31, 0x81	; 129
     8a0:	4f 2e       	mov	r4, r31
     8a2:	f6 e0       	ldi	r31, 0x06	; 6
     8a4:	5f 2e       	mov	r5, r31
     8a6:	f0 2d       	mov	r31, r0
				}
				else
				{
					temp_sample = (uint16_t)((~(temp_sample))+1);
					temp_sample = (temp_sample>>7);
					file_audio[cur] = (uint8_t)temp_sample;
     8a8:	0f 2e       	mov	r0, r31
     8aa:	f5 e6       	ldi	r31, 0x65	; 101
     8ac:	6f 2e       	mov	r6, r31
     8ae:	f2 e0       	ldi	r31, 0x02	; 2
     8b0:	7f 2e       	mov	r7, r31
     8b2:	f0 2d       	mov	r31, r0
				}
				pos = pos +2;
				cur++;
				
				if(pos >= (file_size-512) )
     8b4:	0f 2e       	mov	r0, r31
     8b6:	f1 e8       	ldi	r31, 0x81	; 129
     8b8:	2f 2e       	mov	r2, r31
     8ba:	f4 e0       	ldi	r31, 0x04	; 4
     8bc:	3f 2e       	mov	r3, r31
     8be:	f0 2d       	mov	r31, r0
			}
			j=j+512;
			no_of_read = no_of_read+256;
			if ( cur >= 512 )
			{
				cur=0x00;
     8c0:	1d 86       	std	Y+13, r1	; 0x0d
     8c2:	1e 86       	std	Y+14, r1	; 0x0e
     8c4:	1f 86       	std	Y+15, r1	; 0x0f
     8c6:	18 8a       	std	Y+16, r1	; 0x10
     8c8:	68 01       	movw	r12, r16
	
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	
	do
	{
		first_cluster=curr_cluster;
     8ca:	80 91 65 04 	lds	r24, 0x0465
     8ce:	90 91 66 04 	lds	r25, 0x0466
     8d2:	a0 91 67 04 	lds	r26, 0x0467
     8d6:	b0 91 68 04 	lds	r27, 0x0468
     8da:	80 93 61 02 	sts	0x0261, r24
     8de:	90 93 62 02 	sts	0x0262, r25
     8e2:	a0 93 63 02 	sts	0x0263, r26
     8e6:	b0 93 64 02 	sts	0x0264, r27
		j=0;
		curr_pos=0;
     8ea:	10 92 5d 02 	sts	0x025D, r1
     8ee:	10 92 5e 02 	sts	0x025E, r1
     8f2:	10 92 5f 02 	sts	0x025F, r1
     8f6:	10 92 60 02 	sts	0x0260, r1
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	
	do
	{
		first_cluster=curr_cluster;
		j=0;
     8fa:	19 86       	std	Y+9, r1	; 0x09
     8fc:	1a 86       	std	Y+10, r1	; 0x0a
     8fe:	1b 86       	std	Y+11, r1	; 0x0b
     900:	1c 86       	std	Y+12, r1	; 0x0c
     902:	da 8a       	std	Y+18, r13	; 0x12
     904:	c9 8a       	std	Y+17, r12	; 0x11
		curr_pos=0;
		do
		{
			if (pos == 0x00)
     906:	89 81       	ldd	r24, Y+1	; 0x01
     908:	9a 81       	ldd	r25, Y+2	; 0x02
     90a:	ab 81       	ldd	r26, Y+3	; 0x03
     90c:	bc 81       	ldd	r27, Y+4	; 0x04
     90e:	00 97       	sbiw	r24, 0x00	; 0
     910:	a1 05       	cpc	r26, r1
     912:	b1 05       	cpc	r27, r1
     914:	91 f4       	brne	.+36     	; 0x93a <read_current_file+0x180>
			{
				read_file();
     916:	0e 94 4b 0a 	call	0x1496	; 0x1496 <read_file>
				pos=512;
				j=512;
				extract_headder();
     91a:	0e 94 25 01 	call	0x24a	; 0x24a <extract_headder>
		{
			if (pos == 0x00)
			{
				read_file();
				pos=512;
				j=512;
     91e:	20 e0       	ldi	r18, 0x00	; 0
     920:	32 e0       	ldi	r19, 0x02	; 2
     922:	40 e0       	ldi	r20, 0x00	; 0
     924:	50 e0       	ldi	r21, 0x00	; 0
     926:	29 87       	std	Y+9, r18	; 0x09
     928:	3a 87       	std	Y+10, r19	; 0x0a
     92a:	4b 87       	std	Y+11, r20	; 0x0b
     92c:	5c 87       	std	Y+12, r21	; 0x0c
		do
		{
			if (pos == 0x00)
			{
				read_file();
				pos=512;
     92e:	cc 24       	eor	r12, r12
     930:	dd 24       	eor	r13, r13
     932:	76 01       	movw	r14, r12
     934:	68 94       	set
     936:	d1 f8       	bld	r13, 1
     938:	04 c0       	rjmp	.+8      	; 0x942 <read_current_file+0x188>
		first_cluster=curr_cluster;
		j=0;
		curr_pos=0;
		do
		{
			if (pos == 0x00)
     93a:	c9 80       	ldd	r12, Y+1	; 0x01
     93c:	da 80       	ldd	r13, Y+2	; 0x02
     93e:	eb 80       	ldd	r14, Y+3	; 0x03
     940:	fc 80       	ldd	r15, Y+4	; 0x04
				pos=512;
				j=512;
				extract_headder();
			}
			
			read_file();
     942:	0e 94 4b 0a 	call	0x1496	; 0x1496 <read_file>
			
			while ( (play < (no_of_read + 256))  && (pos > 1536) );
     946:	8d 81       	ldd	r24, Y+5	; 0x05
     948:	9e 81       	ldd	r25, Y+6	; 0x06
     94a:	af 81       	ldd	r26, Y+7	; 0x07
     94c:	b8 85       	ldd	r27, Y+8	; 0x08
     94e:	80 50       	subi	r24, 0x00	; 0
     950:	9f 4f       	sbci	r25, 0xFF	; 255
     952:	af 4f       	sbci	r26, 0xFF	; 255
     954:	bf 4f       	sbci	r27, 0xFF	; 255
     956:	40 91 4e 02 	lds	r20, 0x024E
     95a:	50 91 4f 02 	lds	r21, 0x024F
     95e:	60 91 50 02 	lds	r22, 0x0250
     962:	70 91 51 02 	lds	r23, 0x0251
     966:	48 17       	cp	r20, r24
     968:	59 07       	cpc	r21, r25
     96a:	6a 07       	cpc	r22, r26
     96c:	7b 07       	cpc	r23, r27
     96e:	e0 f0       	brcs	.+56     	; 0x9a8 <read_current_file+0x1ee>
     970:	8d 83       	std	Y+5, r24	; 0x05
     972:	9e 83       	std	Y+6, r25	; 0x06
     974:	af 83       	std	Y+7, r26	; 0x07
     976:	b8 87       	std	Y+8, r27	; 0x08
					file_audio[cur] = (uint8_t)temp_sample;
				}
				pos = pos +2;
				cur++;
				
				if(pos >= (file_size-512) )
     978:	20 91 90 06 	lds	r18, 0x0690
     97c:	30 91 91 06 	lds	r19, 0x0691
     980:	40 91 92 06 	lds	r20, 0x0692
     984:	50 91 93 06 	lds	r21, 0x0693
     988:	29 83       	std	Y+1, r18	; 0x01
     98a:	3a 83       	std	Y+2, r19	; 0x02
     98c:	4b 83       	std	Y+3, r20	; 0x03
     98e:	5c 83       	std	Y+4, r21	; 0x04
     990:	ba 01       	movw	r22, r20
     992:	a9 01       	movw	r20, r18
     994:	40 50       	subi	r20, 0x00	; 0
     996:	52 40       	sbci	r21, 0x02	; 2
     998:	60 40       	sbci	r22, 0x00	; 0
     99a:	70 40       	sbci	r23, 0x00	; 0
     99c:	d1 01       	movw	r26, r2
     99e:	8a 01       	movw	r16, r20
     9a0:	9b 01       	movw	r18, r22
     9a2:	b7 01       	movw	r22, r14
     9a4:	a6 01       	movw	r20, r12
     9a6:	0e c0       	rjmp	.+28     	; 0x9c4 <read_current_file+0x20a>
				extract_headder();
			}
			
			read_file();
			
			while ( (play < (no_of_read + 256))  && (pos > 1536) );
     9a8:	e1 e0       	ldi	r30, 0x01	; 1
     9aa:	ce 16       	cp	r12, r30
     9ac:	e6 e0       	ldi	r30, 0x06	; 6
     9ae:	de 06       	cpc	r13, r30
     9b0:	e0 e0       	ldi	r30, 0x00	; 0
     9b2:	ee 06       	cpc	r14, r30
     9b4:	e0 e0       	ldi	r30, 0x00	; 0
     9b6:	fe 06       	cpc	r15, r30
     9b8:	70 f6       	brcc	.-100    	; 0x956 <read_current_file+0x19c>
     9ba:	8d 83       	std	Y+5, r24	; 0x05
     9bc:	9e 83       	std	Y+6, r25	; 0x06
     9be:	af 83       	std	Y+7, r26	; 0x07
     9c0:	b8 87       	std	Y+8, r27	; 0x08
     9c2:	da cf       	rjmp	.-76     	; 0x978 <read_current_file+0x1be>
			
			for (i=0;i<512;i=i+2)                                          // In this loop we are converting the original 16 bit .wav data to to 8 bit unsigned sample value
			{
				temp_sample = (buffer[i]) | (buffer[i+1]<<8);
     9c4:	8c 91       	ld	r24, X
     9c6:	8a 8b       	std	Y+18, r24	; 0x12
     9c8:	19 8a       	std	Y+17, r1	; 0x11
 * Output: None
 * Logic: This function will call concatenate function and then the read the respective file from sd card and then play
          this file in speaker.
 * Example Call: read_current_file(current_key);
 */
void read_current_file(char key)
     9ca:	fd 01       	movw	r30, r26
     9cc:	31 97       	sbiw	r30, 0x01	; 1
			
			while ( (play < (no_of_read + 256))  && (pos > 1536) );
			
			for (i=0;i<512;i=i+2)                                          // In this loop we are converting the original 16 bit .wav data to to 8 bit unsigned sample value
			{
				temp_sample = (buffer[i]) | (buffer[i+1]<<8);
     9ce:	80 81       	ld	r24, Z
     9d0:	90 e0       	ldi	r25, 0x00	; 0
     9d2:	e9 89       	ldd	r30, Y+17	; 0x11
     9d4:	fa 89       	ldd	r31, Y+18	; 0x12
     9d6:	8e 2b       	or	r24, r30
     9d8:	9f 2b       	or	r25, r31
				
				if ((temp_sample & 0b1000000000000000) == 0x0000 )
     9da:	99 23       	and	r25, r25
     9dc:	54 f0       	brlt	.+20     	; 0x9f2 <read_current_file+0x238>
				{
					temp_sample = (temp_sample>>7);
     9de:	88 0f       	add	r24, r24
     9e0:	89 2f       	mov	r24, r25
     9e2:	88 1f       	adc	r24, r24
     9e4:	99 0b       	sbc	r25, r25
     9e6:	91 95       	neg	r25
					file_audio[cur] = (uint8_t)temp_sample;
     9e8:	f3 01       	movw	r30, r6
     9ea:	e8 0d       	add	r30, r8
     9ec:	f9 1d       	adc	r31, r9
     9ee:	80 83       	st	Z, r24
     9f0:	0c c0       	rjmp	.+24     	; 0xa0a <read_current_file+0x250>
				}
				else
				{
					temp_sample = (uint16_t)((~(temp_sample))+1);
     9f2:	90 95       	com	r25
     9f4:	81 95       	neg	r24
     9f6:	9f 4f       	sbci	r25, 0xFF	; 255
					temp_sample = (temp_sample>>7);
     9f8:	88 0f       	add	r24, r24
     9fa:	89 2f       	mov	r24, r25
     9fc:	88 1f       	adc	r24, r24
     9fe:	99 0b       	sbc	r25, r25
     a00:	91 95       	neg	r25
					file_audio[cur] = (uint8_t)temp_sample;
     a02:	f3 01       	movw	r30, r6
     a04:	e8 0d       	add	r30, r8
     a06:	f9 1d       	adc	r31, r9
     a08:	80 83       	st	Z, r24
				}
				pos = pos +2;
     a0a:	4e 5f       	subi	r20, 0xFE	; 254
     a0c:	5f 4f       	sbci	r21, 0xFF	; 255
     a0e:	6f 4f       	sbci	r22, 0xFF	; 255
     a10:	7f 4f       	sbci	r23, 0xFF	; 255
				cur++;
     a12:	08 94       	sec
     a14:	81 1c       	adc	r8, r1
     a16:	91 1c       	adc	r9, r1
     a18:	a1 1c       	adc	r10, r1
     a1a:	b1 1c       	adc	r11, r1
				
				if(pos >= (file_size-512) )
     a1c:	40 17       	cp	r20, r16
     a1e:	51 07       	cpc	r21, r17
     a20:	62 07       	cpc	r22, r18
     a22:	73 07       	cpc	r23, r19
     a24:	58 f4       	brcc	.+22     	; 0xa3c <read_current_file+0x282>
     a26:	12 96       	adiw	r26, 0x02	; 2
			
			read_file();
			
			while ( (play < (no_of_read + 256))  && (pos > 1536) );
			
			for (i=0;i<512;i=i+2)                                          // In this loop we are converting the original 16 bit .wav data to to 8 bit unsigned sample value
     a28:	a4 15       	cp	r26, r4
     a2a:	b5 05       	cpc	r27, r5
     a2c:	59 f6       	brne	.-106    	; 0x9c4 <read_current_file+0x20a>
					temp_sample = (uint16_t)((~(temp_sample))+1);
					temp_sample = (temp_sample>>7);
					file_audio[cur] = (uint8_t)temp_sample;
				}
				pos = pos +2;
				cur++;
     a2e:	d5 01       	movw	r26, r10
     a30:	c4 01       	movw	r24, r8
				{
					temp_sample = (uint16_t)((~(temp_sample))+1);
					temp_sample = (temp_sample>>7);
					file_audio[cur] = (uint8_t)temp_sample;
				}
				pos = pos +2;
     a32:	49 83       	std	Y+1, r20	; 0x01
     a34:	5a 83       	std	Y+2, r21	; 0x02
     a36:	6b 83       	std	Y+3, r22	; 0x03
     a38:	7c 83       	std	Y+4, r23	; 0x04
     a3a:	02 c0       	rjmp	.+4      	; 0xa40 <read_current_file+0x286>
				cur++;
     a3c:	d5 01       	movw	r26, r10
     a3e:	c4 01       	movw	r24, r8
					break;
				}
			}
			j=j+512;
			no_of_read = no_of_read+256;
			if ( cur >= 512 )
     a40:	80 30       	cpi	r24, 0x00	; 0
     a42:	52 e0       	ldi	r21, 0x02	; 2
     a44:	95 07       	cpc	r25, r21
     a46:	50 e0       	ldi	r21, 0x00	; 0
     a48:	a5 07       	cpc	r26, r21
     a4a:	50 e0       	ldi	r21, 0x00	; 0
     a4c:	b5 07       	cpc	r27, r21
     a4e:	80 f1       	brcs	.+96     	; 0xab0 <read_current_file+0x2f6>
			{
				cur=0x00;
				if (pos <= 1536)
     a50:	89 81       	ldd	r24, Y+1	; 0x01
     a52:	9a 81       	ldd	r25, Y+2	; 0x02
     a54:	ab 81       	ldd	r26, Y+3	; 0x03
     a56:	bc 81       	ldd	r27, Y+4	; 0x04
     a58:	81 30       	cpi	r24, 0x01	; 1
     a5a:	e6 e0       	ldi	r30, 0x06	; 6
     a5c:	9e 07       	cpc	r25, r30
     a5e:	e0 e0       	ldi	r30, 0x00	; 0
     a60:	ae 07       	cpc	r26, r30
     a62:	e0 e0       	ldi	r30, 0x00	; 0
     a64:	be 07       	cpc	r27, r30
     a66:	00 f5       	brcc	.+64     	; 0xaa8 <read_current_file+0x2ee>
				{
					k=0;
     a68:	10 92 5a 02 	sts	0x025A, r1
     a6c:	10 92 59 02 	sts	0x0259, r1
					no_of_read = 0x00;
					play =0x00;
     a70:	2d 85       	ldd	r18, Y+13	; 0x0d
     a72:	3e 85       	ldd	r19, Y+14	; 0x0e
     a74:	4f 85       	ldd	r20, Y+15	; 0x0f
     a76:	58 89       	ldd	r21, Y+16	; 0x10
     a78:	20 93 4e 02 	sts	0x024E, r18
     a7c:	30 93 4f 02 	sts	0x024F, r19
     a80:	40 93 50 02 	sts	0x0250, r20
     a84:	50 93 51 02 	sts	0x0251, r21
					sei();                         // strt the interrupt, pwm, sample timer to play the file.
     a88:	78 94       	sei
					timer2_init();
     a8a:	0e 94 08 01 	call	0x210	; 0x210 <timer2_init>
					timer1_pwm_init();
     a8e:	0e 94 16 01 	call	0x22c	; 0x22c <timer1_pwm_init>
			{
				cur=0x00;
				if (pos <= 1536)
				{
					k=0;
					no_of_read = 0x00;
     a92:	8d 85       	ldd	r24, Y+13	; 0x0d
     a94:	9e 85       	ldd	r25, Y+14	; 0x0e
     a96:	af 85       	ldd	r26, Y+15	; 0x0f
     a98:	b8 89       	ldd	r27, Y+16	; 0x10
     a9a:	8d 83       	std	Y+5, r24	; 0x05
     a9c:	9e 83       	std	Y+6, r25	; 0x06
     a9e:	af 83       	std	Y+7, r26	; 0x07
     aa0:	b8 87       	std	Y+8, r27	; 0x08
			}
			j=j+512;
			no_of_read = no_of_read+256;
			if ( cur >= 512 )
			{
				cur=0x00;
     aa2:	4c 01       	movw	r8, r24
     aa4:	5d 01       	movw	r10, r26
     aa6:	04 c0       	rjmp	.+8      	; 0xab0 <read_current_file+0x2f6>
     aa8:	8d 84       	ldd	r8, Y+13	; 0x0d
     aaa:	9e 84       	ldd	r9, Y+14	; 0x0e
     aac:	af 84       	ldd	r10, Y+15	; 0x0f
     aae:	b8 88       	ldd	r11, Y+16	; 0x10
					timer2_init();
					timer1_pwm_init();
				}
			}
			
		} while (pos < file_size && j <(bytes_per_sector * sectors_per_cluster));
     ab0:	80 91 90 06 	lds	r24, 0x0690
     ab4:	90 91 91 06 	lds	r25, 0x0691
     ab8:	a0 91 92 06 	lds	r26, 0x0692
     abc:	b0 91 93 06 	lds	r27, 0x0693
     ac0:	29 81       	ldd	r18, Y+1	; 0x01
     ac2:	3a 81       	ldd	r19, Y+2	; 0x02
     ac4:	4b 81       	ldd	r20, Y+3	; 0x03
     ac6:	5c 81       	ldd	r21, Y+4	; 0x04
     ac8:	28 17       	cp	r18, r24
     aca:	39 07       	cpc	r19, r25
     acc:	4a 07       	cpc	r20, r26
     ace:	5b 07       	cpc	r21, r27
     ad0:	38 f5       	brcc	.+78     	; 0xb20 <read_current_file+0x366>
				{
					pos = file_size;
					break;
				}
			}
			j=j+512;
     ad2:	89 85       	ldd	r24, Y+9	; 0x09
     ad4:	9a 85       	ldd	r25, Y+10	; 0x0a
     ad6:	ab 85       	ldd	r26, Y+11	; 0x0b
     ad8:	bc 85       	ldd	r27, Y+12	; 0x0c
     ada:	80 50       	subi	r24, 0x00	; 0
     adc:	9e 4f       	sbci	r25, 0xFE	; 254
     ade:	af 4f       	sbci	r26, 0xFF	; 255
     ae0:	bf 4f       	sbci	r27, 0xFF	; 255
     ae2:	89 87       	std	Y+9, r24	; 0x09
     ae4:	9a 87       	std	Y+10, r25	; 0x0a
     ae6:	ab 87       	std	Y+11, r26	; 0x0b
     ae8:	bc 87       	std	Y+12, r27	; 0x0c
					timer2_init();
					timer1_pwm_init();
				}
			}
			
		} while (pos < file_size && j <(bytes_per_sector * sectors_per_cluster));
     aea:	80 91 77 04 	lds	r24, 0x0477
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	20 91 5b 02 	lds	r18, 0x025B
     af4:	30 91 5c 02 	lds	r19, 0x025C
     af8:	82 9f       	mul	r24, r18
     afa:	a0 01       	movw	r20, r0
     afc:	83 9f       	mul	r24, r19
     afe:	50 0d       	add	r21, r0
     b00:	92 9f       	mul	r25, r18
     b02:	50 0d       	add	r21, r0
     b04:	11 24       	eor	r1, r1
     b06:	60 e0       	ldi	r22, 0x00	; 0
     b08:	70 e0       	ldi	r23, 0x00	; 0
     b0a:	89 85       	ldd	r24, Y+9	; 0x09
     b0c:	9a 85       	ldd	r25, Y+10	; 0x0a
     b0e:	ab 85       	ldd	r26, Y+11	; 0x0b
     b10:	bc 85       	ldd	r27, Y+12	; 0x0c
     b12:	84 17       	cp	r24, r20
     b14:	95 07       	cpc	r25, r21
     b16:	a6 07       	cpc	r26, r22
     b18:	b7 07       	cpc	r27, r23
     b1a:	08 f4       	brcc	.+2      	; 0xb1e <read_current_file+0x364>
     b1c:	f4 ce       	rjmp	.-536    	; 0x906 <read_current_file+0x14c>
     b1e:	22 c0       	rjmp	.+68     	; 0xb64 <read_current_file+0x3aa>
			curr_cluster=get_set_next_cluster(GET,first_cluster,0);
			
		}
	} while (pos<file_size);
	
	TIMSK2=0x00;
     b20:	10 92 70 00 	sts	0x0070, r1
	TCCR1B = 0x00;
     b24:	10 92 81 00 	sts	0x0081, r1
	
	SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1) | (1 << SPR0);      // decrease the SPI speed when audio playing is done
     b28:	83 e5       	ldi	r24, 0x53	; 83
     b2a:	8c bd       	out	0x2c, r24	; 44
	
	current_key='0';
     b2c:	80 e3       	ldi	r24, 0x30	; 48
     b2e:	80 93 30 02 	sts	0x0230, r24
	
}
     b32:	62 96       	adiw	r28, 0x12	; 18
     b34:	0f b6       	in	r0, 0x3f	; 63
     b36:	f8 94       	cli
     b38:	de bf       	out	0x3e, r29	; 62
     b3a:	0f be       	out	0x3f, r0	; 63
     b3c:	cd bf       	out	0x3d, r28	; 61
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	1f 91       	pop	r17
     b44:	0f 91       	pop	r16
     b46:	ff 90       	pop	r15
     b48:	ef 90       	pop	r14
     b4a:	df 90       	pop	r13
     b4c:	cf 90       	pop	r12
     b4e:	bf 90       	pop	r11
     b50:	af 90       	pop	r10
     b52:	9f 90       	pop	r9
     b54:	8f 90       	pop	r8
     b56:	7f 90       	pop	r7
     b58:	6f 90       	pop	r6
     b5a:	5f 90       	pop	r5
     b5c:	4f 90       	pop	r4
     b5e:	3f 90       	pop	r3
     b60:	2f 90       	pop	r2
     b62:	08 95       	ret
     b64:	c9 88       	ldd	r12, Y+17	; 0x11
     b66:	da 88       	ldd	r13, Y+18	; 0x12
			
		} while (pos < file_size && j <(bytes_per_sector * sectors_per_cluster));
		
		if(pos<file_size)
		{
			curr_cluster=get_set_next_cluster(GET,first_cluster,0);
     b68:	40 91 61 02 	lds	r20, 0x0261
     b6c:	50 91 62 02 	lds	r21, 0x0262
     b70:	60 91 63 02 	lds	r22, 0x0263
     b74:	70 91 64 02 	lds	r23, 0x0264
     b78:	80 e0       	ldi	r24, 0x00	; 0
     b7a:	00 e0       	ldi	r16, 0x00	; 0
     b7c:	10 e0       	ldi	r17, 0x00	; 0
     b7e:	98 01       	movw	r18, r16
     b80:	0e 94 c4 07 	call	0xf88	; 0xf88 <get_set_next_cluster>
     b84:	dc 01       	movw	r26, r24
     b86:	cb 01       	movw	r24, r22
     b88:	80 93 65 04 	sts	0x0465, r24
     b8c:	90 93 66 04 	sts	0x0466, r25
     b90:	a0 93 67 04 	sts	0x0467, r26
     b94:	b0 93 68 04 	sts	0x0468, r27
			
		}
	} while (pos<file_size);
     b98:	80 91 90 06 	lds	r24, 0x0690
     b9c:	90 91 91 06 	lds	r25, 0x0691
     ba0:	a0 91 92 06 	lds	r26, 0x0692
     ba4:	b0 91 93 06 	lds	r27, 0x0693
     ba8:	29 81       	ldd	r18, Y+1	; 0x01
     baa:	3a 81       	ldd	r19, Y+2	; 0x02
     bac:	4b 81       	ldd	r20, Y+3	; 0x03
     bae:	5c 81       	ldd	r21, Y+4	; 0x04
     bb0:	28 17       	cp	r18, r24
     bb2:	39 07       	cpc	r19, r25
     bb4:	4a 07       	cpc	r20, r26
     bb6:	5b 07       	cpc	r21, r27
     bb8:	08 f4       	brcc	.+2      	; 0xbbc <read_current_file+0x402>
     bba:	87 ce       	rjmp	.-754    	; 0x8ca <read_current_file+0x110>
     bbc:	b1 cf       	rjmp	.-158    	; 0xb20 <read_current_file+0x366>

00000bbe <__vector_5>:
 * Logic: This routine will sense the IRQ pin from the mpr121, so that whenever their is touch
          we can read the status resister of mpr121 and get the touch status of mpr121.
 */

ISR (INT4_vect)
{
     bbe:	1f 92       	push	r1
     bc0:	0f 92       	push	r0
     bc2:	0f b6       	in	r0, 0x3f	; 63
     bc4:	0f 92       	push	r0
     bc6:	0b b6       	in	r0, 0x3b	; 59
     bc8:	0f 92       	push	r0
     bca:	11 24       	eor	r1, r1
     bcc:	2f 93       	push	r18
     bce:	3f 93       	push	r19
     bd0:	4f 93       	push	r20
     bd2:	5f 93       	push	r21
     bd4:	6f 93       	push	r22
     bd6:	7f 93       	push	r23
     bd8:	8f 93       	push	r24
     bda:	9f 93       	push	r25
     bdc:	af 93       	push	r26
     bde:	bf 93       	push	r27
     be0:	ef 93       	push	r30
     be2:	ff 93       	push	r31
	get_raw_values();
     be4:	0e 94 cf 02 	call	0x59e	; 0x59e <get_raw_values>
	
	
}
     be8:	ff 91       	pop	r31
     bea:	ef 91       	pop	r30
     bec:	bf 91       	pop	r27
     bee:	af 91       	pop	r26
     bf0:	9f 91       	pop	r25
     bf2:	8f 91       	pop	r24
     bf4:	7f 91       	pop	r23
     bf6:	6f 91       	pop	r22
     bf8:	5f 91       	pop	r21
     bfa:	4f 91       	pop	r20
     bfc:	3f 91       	pop	r19
     bfe:	2f 91       	pop	r18
     c00:	0f 90       	pop	r0
     c02:	0b be       	out	0x3b, r0	; 59
     c04:	0f 90       	pop	r0
     c06:	0f be       	out	0x3f, r0	; 63
     c08:	0f 90       	pop	r0
     c0a:	1f 90       	pop	r1
     c0c:	18 95       	reti

00000c0e <__vector_13>:
/* 
 * ISR Name: Timer2 compare match A 
 * Logic: This routine will give the values of file_audio to pwm of timer 0 to play the speaker as per the sample rate
 */
ISR(TIMER2_COMPA_vect)
{
     c0e:	1f 92       	push	r1
     c10:	0f 92       	push	r0
     c12:	0f b6       	in	r0, 0x3f	; 63
     c14:	0f 92       	push	r0
     c16:	0b b6       	in	r0, 0x3b	; 59
     c18:	0f 92       	push	r0
     c1a:	11 24       	eor	r1, r1
     c1c:	2f 93       	push	r18
     c1e:	8f 93       	push	r24
     c20:	9f 93       	push	r25
     c22:	af 93       	push	r26
     c24:	bf 93       	push	r27
     c26:	ef 93       	push	r30
     c28:	ff 93       	push	r31
	OCR1AL = file_audio[k];
     c2a:	e0 91 59 02 	lds	r30, 0x0259
     c2e:	f0 91 5a 02 	lds	r31, 0x025A
     c32:	eb 59       	subi	r30, 0x9B	; 155
     c34:	fd 4f       	sbci	r31, 0xFD	; 253
     c36:	80 81       	ld	r24, Z
     c38:	80 93 88 00 	sts	0x0088, r24
	k=k+1;
     c3c:	80 91 59 02 	lds	r24, 0x0259
     c40:	90 91 5a 02 	lds	r25, 0x025A
     c44:	01 96       	adiw	r24, 0x01	; 1
     c46:	90 93 5a 02 	sts	0x025A, r25
     c4a:	80 93 59 02 	sts	0x0259, r24
	play = play+1;
     c4e:	80 91 4e 02 	lds	r24, 0x024E
     c52:	90 91 4f 02 	lds	r25, 0x024F
     c56:	a0 91 50 02 	lds	r26, 0x0250
     c5a:	b0 91 51 02 	lds	r27, 0x0251
     c5e:	01 96       	adiw	r24, 0x01	; 1
     c60:	a1 1d       	adc	r26, r1
     c62:	b1 1d       	adc	r27, r1
     c64:	80 93 4e 02 	sts	0x024E, r24
     c68:	90 93 4f 02 	sts	0x024F, r25
     c6c:	a0 93 50 02 	sts	0x0250, r26
     c70:	b0 93 51 02 	sts	0x0251, r27
	if (k >= 512)
     c74:	80 91 59 02 	lds	r24, 0x0259
     c78:	90 91 5a 02 	lds	r25, 0x025A
     c7c:	22 e0       	ldi	r18, 0x02	; 2
     c7e:	80 30       	cpi	r24, 0x00	; 0
     c80:	92 07       	cpc	r25, r18
     c82:	20 f0       	brcs	.+8      	; 0xc8c <__vector_13+0x7e>
	{
		k=0;
     c84:	10 92 5a 02 	sts	0x025A, r1
     c88:	10 92 59 02 	sts	0x0259, r1
	}

}
     c8c:	ff 91       	pop	r31
     c8e:	ef 91       	pop	r30
     c90:	bf 91       	pop	r27
     c92:	af 91       	pop	r26
     c94:	9f 91       	pop	r25
     c96:	8f 91       	pop	r24
     c98:	2f 91       	pop	r18
     c9a:	0f 90       	pop	r0
     c9c:	0b be       	out	0x3b, r0	; 59
     c9e:	0f 90       	pop	r0
     ca0:	0f be       	out	0x3f, r0	; 63
     ca2:	0f 90       	pop	r0
     ca4:	1f 90       	pop	r1
     ca6:	18 95       	reti

00000ca8 <main>:


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MAIN FUNCTION ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
int main(void)
{
	boot_switch_pin_config();
     ca8:	0e 94 15 03 	call	0x62a	; 0x62a <boot_switch_pin_config>
	initialise_device();
     cac:	0e 94 21 03 	call	0x642	; 0x642 <initialise_device>
	uart0_init();
     cb0:	0e 94 91 01 	call	0x322	; 0x322 <uart0_init>
	DDRB|=0b00100000;                          // port config speaker.
     cb4:	25 9a       	sbi	0x04, 5	; 4
	{
		// if boot switch is pressed
		if ((PIND & 0x40) != 0x40)
		{
			switch_flag = 1;
			uart_tx_string("#");
     cb6:	ca e1       	ldi	r28, 0x1A	; 26
     cb8:	d2 e0       	ldi	r29, 0x02	; 2
			uart_tx_string("\n");
     cba:	00 e0       	ldi	r16, 0x00	; 0
     cbc:	12 e0       	ldi	r17, 0x02	; 2
{
	boot_switch_pin_config();
	initialise_device();
	uart0_init();
	DDRB|=0b00100000;                          // port config speaker.
	while(switch_flag == 0x00)
     cbe:	0b c0       	rjmp	.+22     	; 0xcd6 <main+0x2e>
	{
		// if boot switch is pressed
		if ((PIND & 0x40) != 0x40)
     cc0:	4e 99       	sbic	0x09, 6	; 9
     cc2:	fe cf       	rjmp	.-4      	; 0xcc0 <main+0x18>
		{
			switch_flag = 1;
     cc4:	81 e0       	ldi	r24, 0x01	; 1
     cc6:	80 93 3e 02 	sts	0x023E, r24
			uart_tx_string("#");
     cca:	ce 01       	movw	r24, r28
     ccc:	0e 94 ac 01 	call	0x358	; 0x358 <uart_tx_string>
			uart_tx_string("\n");
     cd0:	c8 01       	movw	r24, r16
     cd2:	0e 94 ac 01 	call	0x358	; 0x358 <uart_tx_string>
{
	boot_switch_pin_config();
	initialise_device();
	uart0_init();
	DDRB|=0b00100000;                          // port config speaker.
	while(switch_flag == 0x00)
     cd6:	80 91 3e 02 	lds	r24, 0x023E
     cda:	88 23       	and	r24, r24
     cdc:	89 f3       	breq	.-30     	; 0xcc0 <main+0x18>
			uart_tx_string("#");
			uart_tx_string("\n");
		}
	}
	
	IRQ_interrupt_init();                      // enable interrupt for mpr121.
     cde:	0e 94 8c 01 	call	0x318	; 0x318 <IRQ_interrupt_init>
     ce2:	ff cf       	rjmp	.-2      	; 0xce2 <main+0x3a>

00000ce4 <get_set_free_cluster>:
}


// to get or set next free cluster or total free clusters in FS_info sector of SD card
unsigned long get_set_free_cluster(unsigned char get_set, unsigned char tot_or_next, unsigned long FS_entry)
{
     ce4:	cf 92       	push	r12
     ce6:	df 92       	push	r13
     ce8:	ef 92       	push	r14
     cea:	ff 92       	push	r15
     cec:	0f 93       	push	r16
     cee:	1f 93       	push	r17
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
     cf4:	c8 2f       	mov	r28, r24
     cf6:	d6 2f       	mov	r29, r22
     cf8:	69 01       	movw	r12, r18
     cfa:	7a 01       	movw	r14, r20
	struct FS_info *fs_info_sector;
	
	fs_info_sector = (struct FS_info *) &buffer;
	
	read_single_block(unused_sector + 1);
     cfc:	80 91 80 06 	lds	r24, 0x0680
     d00:	90 91 81 06 	lds	r25, 0x0681
     d04:	01 96       	adiw	r24, 0x01	; 1
     d06:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <read_single_block>
	
	if ((fs_info_sector->lead_signature != 0x41615252) && (fs_info_sector->structure_signature != 0x61417272) && (fs_info_sector->trail_signature != 0xAA550000))
     d0a:	80 91 80 04 	lds	r24, 0x0480
     d0e:	90 91 81 04 	lds	r25, 0x0481
     d12:	a0 91 82 04 	lds	r26, 0x0482
     d16:	b0 91 83 04 	lds	r27, 0x0483
     d1a:	82 35       	cpi	r24, 0x52	; 82
     d1c:	22 e5       	ldi	r18, 0x52	; 82
     d1e:	92 07       	cpc	r25, r18
     d20:	21 e6       	ldi	r18, 0x61	; 97
     d22:	a2 07       	cpc	r26, r18
     d24:	21 e4       	ldi	r18, 0x41	; 65
     d26:	b2 07       	cpc	r27, r18
     d28:	01 f1       	breq	.+64     	; 0xd6a <get_set_free_cluster+0x86>
     d2a:	80 91 64 06 	lds	r24, 0x0664
     d2e:	90 91 65 06 	lds	r25, 0x0665
     d32:	a0 91 66 06 	lds	r26, 0x0666
     d36:	b0 91 67 06 	lds	r27, 0x0667
     d3a:	82 37       	cpi	r24, 0x72	; 114
     d3c:	22 e7       	ldi	r18, 0x72	; 114
     d3e:	92 07       	cpc	r25, r18
     d40:	21 e4       	ldi	r18, 0x41	; 65
     d42:	a2 07       	cpc	r26, r18
     d44:	21 e6       	ldi	r18, 0x61	; 97
     d46:	b2 07       	cpc	r27, r18
     d48:	81 f0       	breq	.+32     	; 0xd6a <get_set_free_cluster+0x86>
     d4a:	80 91 7c 06 	lds	r24, 0x067C
     d4e:	90 91 7d 06 	lds	r25, 0x067D
     d52:	a0 91 7e 06 	lds	r26, 0x067E
     d56:	b0 91 7f 06 	lds	r27, 0x067F
     d5a:	80 30       	cpi	r24, 0x00	; 0
     d5c:	20 e0       	ldi	r18, 0x00	; 0
     d5e:	92 07       	cpc	r25, r18
     d60:	25 e5       	ldi	r18, 0x55	; 85
     d62:	a2 07       	cpc	r26, r18
     d64:	2a ea       	ldi	r18, 0xAA	; 170
     d66:	b2 07       	cpc	r27, r18
     d68:	81 f5       	brne	.+96     	; 0xdca <get_set_free_cluster+0xe6>
	{
		return 0;
	}
	
	if (get_set == GET)
     d6a:	cc 23       	and	r28, r28
     d6c:	a1 f4       	brne	.+40     	; 0xd96 <get_set_free_cluster+0xb2>
	{
		if (tot_or_next == TOTAL_FREE)
     d6e:	d1 30       	cpi	r29, 0x01	; 1
     d70:	49 f4       	brne	.+18     	; 0xd84 <get_set_free_cluster+0xa0>
		{
			return fs_info_sector->free_cluster_count;
     d72:	00 91 68 06 	lds	r16, 0x0668
     d76:	10 91 69 06 	lds	r17, 0x0669
     d7a:	20 91 6a 06 	lds	r18, 0x066A
     d7e:	30 91 6b 06 	lds	r19, 0x066B
     d82:	26 c0       	rjmp	.+76     	; 0xdd0 <get_set_free_cluster+0xec>
		}
		else	// tot_or_next == NEXT_FREE
		{
			return fs_info_sector->next_free_cluster;
     d84:	00 91 6c 06 	lds	r16, 0x066C
     d88:	10 91 6d 06 	lds	r17, 0x066D
     d8c:	20 91 6e 06 	lds	r18, 0x066E
     d90:	30 91 6f 06 	lds	r19, 0x066F
     d94:	1d c0       	rjmp	.+58     	; 0xdd0 <get_set_free_cluster+0xec>
		}
	}
	else	// get_set == SET 			// this is not being used in this Theme
	{
		if (tot_or_next == TOTAL_FREE)
     d96:	d1 30       	cpi	r29, 0x01	; 1
     d98:	61 f4       	brne	.+24     	; 0xdb2 <get_set_free_cluster+0xce>
		{
			fs_info_sector->free_cluster_count = FS_entry;
     d9a:	c0 92 68 06 	sts	0x0668, r12
     d9e:	d0 92 69 06 	sts	0x0669, r13
     da2:	e0 92 6a 06 	sts	0x066A, r14
     da6:	f0 92 6b 06 	sts	0x066B, r15
		{
			fs_info_sector->next_free_cluster = FS_entry;
		}
	}
	
	return 0xFFFFFFFF;
     daa:	0f ef       	ldi	r16, 0xFF	; 255
     dac:	1f ef       	ldi	r17, 0xFF	; 255
     dae:	98 01       	movw	r18, r16
     db0:	0f c0       	rjmp	.+30     	; 0xdd0 <get_set_free_cluster+0xec>
		{
			fs_info_sector->free_cluster_count = FS_entry;
		}
		else	// tot_or_next == NEXT_FREE
		{
			fs_info_sector->next_free_cluster = FS_entry;
     db2:	c0 92 6c 06 	sts	0x066C, r12
     db6:	d0 92 6d 06 	sts	0x066D, r13
     dba:	e0 92 6e 06 	sts	0x066E, r14
     dbe:	f0 92 6f 06 	sts	0x066F, r15
		}
	}
	
	return 0xFFFFFFFF;
     dc2:	0f ef       	ldi	r16, 0xFF	; 255
     dc4:	1f ef       	ldi	r17, 0xFF	; 255
     dc6:	98 01       	movw	r18, r16
     dc8:	03 c0       	rjmp	.+6      	; 0xdd0 <get_set_free_cluster+0xec>
	
	read_single_block(unused_sector + 1);
	
	if ((fs_info_sector->lead_signature != 0x41615252) && (fs_info_sector->structure_signature != 0x61417272) && (fs_info_sector->trail_signature != 0xAA550000))
	{
		return 0;
     dca:	00 e0       	ldi	r16, 0x00	; 0
     dcc:	10 e0       	ldi	r17, 0x00	; 0
     dce:	98 01       	movw	r18, r16
			fs_info_sector->next_free_cluster = FS_entry;
		}
	}
	
	return 0xFFFFFFFF;
}
     dd0:	60 2f       	mov	r22, r16
     dd2:	71 2f       	mov	r23, r17
     dd4:	82 2f       	mov	r24, r18
     dd6:	93 2f       	mov	r25, r19
     dd8:	df 91       	pop	r29
     dda:	cf 91       	pop	r28
     ddc:	1f 91       	pop	r17
     dde:	0f 91       	pop	r16
     de0:	ff 90       	pop	r15
     de2:	ef 90       	pop	r14
     de4:	df 90       	pop	r13
     de6:	cf 90       	pop	r12
     de8:	08 95       	ret

00000dea <get_boot_sector_data>:
#include "FAT32.h"


// initialize FAT32 and get the data from the Boot sector of SD card
unsigned char get_boot_sector_data()
{
     dea:	cf 92       	push	r12
     dec:	df 92       	push	r13
     dee:	ef 92       	push	r14
     df0:	ff 92       	push	r15
     df2:	0f 93       	push	r16
     df4:	1f 93       	push	r17
     df6:	cf 93       	push	r28
	struct BS_info *boot_sector;
	struct MBR_info *master_boot_rec;
	struct Partition_info *partition;
	
	unsigned long data_sectors;
	unused_sector = 0;
     df8:	10 92 80 06 	sts	0x0680, r1
     dfc:	10 92 81 06 	sts	0x0681, r1
     e00:	10 92 82 06 	sts	0x0682, r1
     e04:	10 92 83 06 	sts	0x0683, r1
	
	read_single_block(0);
     e08:	80 e0       	ldi	r24, 0x00	; 0
     e0a:	90 e0       	ldi	r25, 0x00	; 0
     e0c:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <read_single_block>
	if (boot_sector->jump_boot[0] != 0xE9 || boot_sector->jump_boot[0] != 0xEB)
	{
		// if it is not boot sector, it must be MBR
		master_boot_rec = (struct MBR_info *) buffer;
		
		if (master_boot_rec->signature != 0xAA55)
     e10:	80 91 7e 06 	lds	r24, 0x067E
     e14:	90 91 7f 06 	lds	r25, 0x067F
     e18:	0a ea       	ldi	r16, 0xAA	; 170
     e1a:	85 35       	cpi	r24, 0x55	; 85
     e1c:	90 07       	cpc	r25, r16
     e1e:	09 f0       	breq	.+2      	; 0xe22 <get_boot_sector_data+0x38>
     e20:	a8 c0       	rjmp	.+336    	; 0xf72 <get_boot_sector_data+0x188>
		}
		
		partition = (struct Partition_info *) (master_boot_rec->partition_data);
		
		// the unused sectors, hidden to the FAT
		unused_sector = partition->first_sector;
     e22:	80 91 46 06 	lds	r24, 0x0646
     e26:	90 91 47 06 	lds	r25, 0x0647
     e2a:	ac 01       	movw	r20, r24
     e2c:	60 e0       	ldi	r22, 0x00	; 0
     e2e:	70 e0       	ldi	r23, 0x00	; 0
     e30:	40 93 80 06 	sts	0x0680, r20
     e34:	50 93 81 06 	sts	0x0681, r21
     e38:	60 93 82 06 	sts	0x0682, r22
     e3c:	70 93 83 06 	sts	0x0683, r23
		
		// read the boot sector
		read_single_block(unused_sector);
     e40:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <read_single_block>
		
		boot_sector = (struct BS_info *) buffer;
		
		if ((boot_sector->jump_boot[0] != 0xEB) && (boot_sector->jump_boot[0] != 0xE9))
     e44:	80 91 80 04 	lds	r24, 0x0480
     e48:	8b 3e       	cpi	r24, 0xEB	; 235
     e4a:	19 f0       	breq	.+6      	; 0xe52 <get_boot_sector_data+0x68>
     e4c:	89 3e       	cpi	r24, 0xE9	; 233
     e4e:	09 f0       	breq	.+2      	; 0xe52 <get_boot_sector_data+0x68>
     e50:	92 c0       	rjmp	.+292    	; 0xf76 <get_boot_sector_data+0x18c>
		{
			return 0;
		}
	}
	
	bytes_per_sector = boot_sector->bytes_per_sector;
     e52:	80 91 8b 04 	lds	r24, 0x048B
     e56:	90 91 8c 04 	lds	r25, 0x048C
     e5a:	90 93 5c 02 	sts	0x025C, r25
     e5e:	80 93 5b 02 	sts	0x025B, r24
	sectors_per_cluster = boot_sector->sectors_per_cluster;
     e62:	c0 91 8d 04 	lds	r28, 0x048D
     e66:	c0 93 77 04 	sts	0x0477, r28
	reserved_sector_count = boot_sector->reserved_sector_count;
     e6a:	c0 90 8e 04 	lds	r12, 0x048E
     e6e:	d0 90 8f 04 	lds	r13, 0x048F
     e72:	d0 92 6a 04 	sts	0x046A, r13
     e76:	c0 92 69 04 	sts	0x0469, r12
	// lcd_numeric_value(1, 1, bytes_per_sector, 5);
	// lcd_numeric_value(1, 8, sectors_per_cluster, 5);
	// lcd_numeric_value(2, 1, reserved_sector_count, 5);
	//_delay_ms(500);
	
	root_cluster = boot_sector->root_cluster;
     e7a:	80 91 ac 04 	lds	r24, 0x04AC
     e7e:	90 91 ad 04 	lds	r25, 0x04AD
     e82:	a0 91 ae 04 	lds	r26, 0x04AE
     e86:	b0 91 af 04 	lds	r27, 0x04AF
     e8a:	80 93 85 06 	sts	0x0685, r24
     e8e:	90 93 86 06 	sts	0x0686, r25
     e92:	a0 93 87 06 	sts	0x0687, r26
     e96:	b0 93 88 06 	sts	0x0688, r27
	
	first_data_sector = boot_sector->hidden_sectors + reserved_sector_count
     e9a:	ee 24       	eor	r14, r14
     e9c:	ff 24       	eor	r15, r15
						+ (boot_sector->FATsize_F32 * boot_sector->number_of_FATs);
     e9e:	60 91 90 04 	lds	r22, 0x0490
     ea2:	70 e0       	ldi	r23, 0x00	; 0
     ea4:	80 e0       	ldi	r24, 0x00	; 0
     ea6:	90 e0       	ldi	r25, 0x00	; 0
     ea8:	20 91 a4 04 	lds	r18, 0x04A4
     eac:	30 91 a5 04 	lds	r19, 0x04A5
     eb0:	40 91 a6 04 	lds	r20, 0x04A6
     eb4:	50 91 a7 04 	lds	r21, 0x04A7
     eb8:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <__mulsi3>
     ebc:	dc 01       	movw	r26, r24
     ebe:	cb 01       	movw	r24, r22
	// lcd_numeric_value(2, 1, reserved_sector_count, 5);
	//_delay_ms(500);
	
	root_cluster = boot_sector->root_cluster;
	
	first_data_sector = boot_sector->hidden_sectors + reserved_sector_count
     ec0:	40 91 9c 04 	lds	r20, 0x049C
     ec4:	50 91 9d 04 	lds	r21, 0x049D
     ec8:	60 91 9e 04 	lds	r22, 0x049E
     ecc:	70 91 9f 04 	lds	r23, 0x049F
     ed0:	4c 0d       	add	r20, r12
     ed2:	5d 1d       	adc	r21, r13
     ed4:	6e 1d       	adc	r22, r14
     ed6:	7f 1d       	adc	r23, r15
						+ (boot_sector->FATsize_F32 * boot_sector->number_of_FATs);
     ed8:	48 0f       	add	r20, r24
     eda:	59 1f       	adc	r21, r25
     edc:	6a 1f       	adc	r22, r26
     ede:	7b 1f       	adc	r23, r27
	// lcd_numeric_value(2, 1, reserved_sector_count, 5);
	//_delay_ms(500);
	
	root_cluster = boot_sector->root_cluster;
	
	first_data_sector = boot_sector->hidden_sectors + reserved_sector_count
     ee0:	40 93 89 06 	sts	0x0689, r20
     ee4:	50 93 8a 06 	sts	0x068A, r21
     ee8:	60 93 8b 06 	sts	0x068B, r22
     eec:	70 93 8c 06 	sts	0x068C, r23
						+ (boot_sector->FATsize_F32 * boot_sector->number_of_FATs);
	
	data_sectors = boot_sector->total_sectors_F32 - reserved_sector_count
     ef0:	40 91 a0 04 	lds	r20, 0x04A0
     ef4:	50 91 a1 04 	lds	r21, 0x04A1
     ef8:	60 91 a2 04 	lds	r22, 0x04A2
     efc:	70 91 a3 04 	lds	r23, 0x04A3
     f00:	4c 19       	sub	r20, r12
     f02:	5d 09       	sbc	r21, r13
     f04:	6e 09       	sbc	r22, r14
     f06:	7f 09       	sbc	r23, r15
     f08:	8a 01       	movw	r16, r20
     f0a:	9b 01       	movw	r18, r22
     f0c:	08 1b       	sub	r16, r24
     f0e:	19 0b       	sbc	r17, r25
     f10:	2a 0b       	sbc	r18, r26
     f12:	3b 0b       	sbc	r19, r27
     f14:	c9 01       	movw	r24, r18
     f16:	b8 01       	movw	r22, r16
	//lcd_numeric_value(2, 1, sectors_per_cluster, 5);
	//_delay_ms(500);
	
	double _tmp = (1.0 / sectors_per_cluster);
	
	total_clusters = (unsigned long)((double)data_sectors * _tmp);
     f18:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <__floatunsisf>
     f1c:	6b 01       	movw	r12, r22
     f1e:	7c 01       	movw	r14, r24
	//lcd_clear();
	//lcd_numeric_value(1, 1, data_sectors - 31090000, 5);		// since number larger than 5 digits cannot be displayed on LCD
	//lcd_numeric_value(2, 1, sectors_per_cluster, 5);
	//_delay_ms(500);
	
	double _tmp = (1.0 / sectors_per_cluster);
     f20:	6c 2f       	mov	r22, r28
     f22:	70 e0       	ldi	r23, 0x00	; 0
     f24:	80 e0       	ldi	r24, 0x00	; 0
     f26:	90 e0       	ldi	r25, 0x00	; 0
     f28:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <__floatsisf>
     f2c:	9b 01       	movw	r18, r22
     f2e:	ac 01       	movw	r20, r24
     f30:	60 e0       	ldi	r22, 0x00	; 0
     f32:	70 e0       	ldi	r23, 0x00	; 0
     f34:	80 e8       	ldi	r24, 0x80	; 128
     f36:	9f e3       	ldi	r25, 0x3F	; 63
     f38:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <__divsf3>
     f3c:	9b 01       	movw	r18, r22
     f3e:	ac 01       	movw	r20, r24
	
	total_clusters = (unsigned long)((double)data_sectors * _tmp);
     f40:	c7 01       	movw	r24, r14
     f42:	b6 01       	movw	r22, r12
     f44:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <__mulsf3>
     f48:	0e 94 01 0e 	call	0x1c02	; 0x1c02 <__fixunssfsi>
     f4c:	dc 01       	movw	r26, r24
     f4e:	cb 01       	movw	r24, r22
     f50:	80 93 7c 04 	sts	0x047C, r24
     f54:	90 93 7d 04 	sts	0x047D, r25
     f58:	a0 93 7e 04 	sts	0x047E, r26
     f5c:	b0 93 7f 04 	sts	0x047F, r27
	//lcd_string(1, 1, "clusters: 48");
	//lcd_numeric_value(1, 13, (total_clusters - 480000), 4);		// since number larger than 5 digits cannot be displayed on LCD
	//_delay_ms(500);
	
	// check if FS_info free cluster count is valid
	if (get_set_free_cluster(GET, TOTAL_FREE, 0) < total_clusters)
     f60:	80 e0       	ldi	r24, 0x00	; 0
     f62:	61 e0       	ldi	r22, 0x01	; 1
     f64:	20 e0       	ldi	r18, 0x00	; 0
     f66:	30 e0       	ldi	r19, 0x00	; 0
     f68:	a9 01       	movw	r20, r18
     f6a:	0e 94 72 06 	call	0xce4	; 0xce4 <get_set_free_cluster>
		//lcd_clear();
		//lcd_string(2, 1, "fs_info correct");
		//_delay_ms(500);
	}
	
	return 1;	
     f6e:	81 e0       	ldi	r24, 0x01	; 1
     f70:	03 c0       	rjmp	.+6      	; 0xf78 <get_boot_sector_data+0x18e>
		master_boot_rec = (struct MBR_info *) buffer;
		
		if (master_boot_rec->signature != 0xAA55)
		{
			// if it is not even MBR, then it's not FAT32
			return 0;
     f72:	80 e0       	ldi	r24, 0x00	; 0
     f74:	01 c0       	rjmp	.+2      	; 0xf78 <get_boot_sector_data+0x18e>
		
		boot_sector = (struct BS_info *) buffer;
		
		if ((boot_sector->jump_boot[0] != 0xEB) && (boot_sector->jump_boot[0] != 0xE9))
		{
			return 0;
     f76:	80 e0       	ldi	r24, 0x00	; 0
		//lcd_string(2, 1, "fs_info correct");
		//_delay_ms(500);
	}
	
	return 1;	
}
     f78:	cf 91       	pop	r28
     f7a:	1f 91       	pop	r17
     f7c:	0f 91       	pop	r16
     f7e:	ff 90       	pop	r15
     f80:	ef 90       	pop	r14
     f82:	df 90       	pop	r13
     f84:	cf 90       	pop	r12
     f86:	08 95       	ret

00000f88 <get_set_next_cluster>:
}


// get cluster entry value from FAT to find out the next cluster in the chain
unsigned long get_set_next_cluster(unsigned char get_set, unsigned long cluster_number, unsigned long cluster_entry)
{
     f88:	3f 92       	push	r3
     f8a:	4f 92       	push	r4
     f8c:	5f 92       	push	r5
     f8e:	6f 92       	push	r6
     f90:	7f 92       	push	r7
     f92:	8f 92       	push	r8
     f94:	9f 92       	push	r9
     f96:	af 92       	push	r10
     f98:	bf 92       	push	r11
     f9a:	cf 92       	push	r12
     f9c:	df 92       	push	r13
     f9e:	ef 92       	push	r14
     fa0:	ff 92       	push	r15
     fa2:	0f 93       	push	r16
     fa4:	1f 93       	push	r17
     fa6:	cf 93       	push	r28
     fa8:	df 93       	push	r29
     faa:	00 d0       	rcall	.+0      	; 0xfac <get_set_next_cluster+0x24>
     fac:	0f 92       	push	r0
     fae:	cd b7       	in	r28, 0x3d	; 61
     fb0:	de b7       	in	r29, 0x3e	; 62
     fb2:	38 2e       	mov	r3, r24
     fb4:	09 83       	std	Y+1, r16	; 0x01
     fb6:	1a 83       	std	Y+2, r17	; 0x02
     fb8:	2b 83       	std	Y+3, r18	; 0x03
     fba:	3c 83       	std	Y+4, r19	; 0x04
	unsigned int FAT_entry_offset;
	unsigned long *FAT_entry_value, FAT_entry_sector;
	unsigned char retry = 0;
	
	// get sector number of the cluster entry in the FAT
	FAT_entry_sector = unused_sector + reserved_sector_count + ((cluster_number * 4) / bytes_per_sector);
     fbc:	cb 01       	movw	r24, r22
     fbe:	ba 01       	movw	r22, r20
     fc0:	66 0f       	add	r22, r22
     fc2:	77 1f       	adc	r23, r23
     fc4:	88 1f       	adc	r24, r24
     fc6:	99 1f       	adc	r25, r25
     fc8:	66 0f       	add	r22, r22
     fca:	77 1f       	adc	r23, r23
     fcc:	88 1f       	adc	r24, r24
     fce:	99 1f       	adc	r25, r25
     fd0:	80 90 5b 02 	lds	r8, 0x025B
     fd4:	90 90 5c 02 	lds	r9, 0x025C
     fd8:	aa 24       	eor	r10, r10
     fda:	bb 24       	eor	r11, r11
     fdc:	c0 90 69 04 	lds	r12, 0x0469
     fe0:	d0 90 6a 04 	lds	r13, 0x046A
     fe4:	ee 24       	eor	r14, r14
     fe6:	ff 24       	eor	r15, r15
     fe8:	00 91 80 06 	lds	r16, 0x0680
     fec:	10 91 81 06 	lds	r17, 0x0681
     ff0:	20 91 82 06 	lds	r18, 0x0682
     ff4:	30 91 83 06 	lds	r19, 0x0683
     ff8:	26 01       	movw	r4, r12
     ffa:	37 01       	movw	r6, r14
     ffc:	40 0e       	add	r4, r16
     ffe:	51 1e       	adc	r5, r17
    1000:	62 1e       	adc	r6, r18
    1002:	73 1e       	adc	r7, r19
    1004:	a5 01       	movw	r20, r10
    1006:	94 01       	movw	r18, r8
    1008:	0e 94 64 0f 	call	0x1ec8	; 0x1ec8 <__udivmodsi4>
    100c:	69 01       	movw	r12, r18
    100e:	7a 01       	movw	r14, r20
    1010:	8b 01       	movw	r16, r22
    1012:	9c 01       	movw	r18, r24
    1014:	c4 0c       	add	r12, r4
    1016:	d5 1c       	adc	r13, r5
    1018:	e6 1c       	adc	r14, r6
    101a:	f7 1c       	adc	r15, r7
	
	// get the offset address in that sector number
	FAT_entry_offset = (unsigned int) ((cluster_number * 4) % bytes_per_sector);
    101c:	0f 2e       	mov	r0, r31
    101e:	fa e0       	ldi	r31, 0x0A	; 10
    1020:	8f 2e       	mov	r8, r31
    1022:	f0 2d       	mov	r31, r0
	//_delay_ms(500);
	
	// read the sector into a buffer
	while (retry < 10)
	{
		if (read_single_block(FAT_entry_sector))
    1024:	c6 01       	movw	r24, r12
    1026:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <read_single_block>
    102a:	88 23       	and	r24, r24
    102c:	11 f4       	brne	.+4      	; 0x1032 <get_set_next_cluster+0xaa>
    102e:	8a 94       	dec	r8
	//lcd_numeric_value(1, 1, FAT_entry_sector, 5);
	//lcd_numeric_value(2, 1, FAT_entry_offset, 5);
	//_delay_ms(500);
	
	// read the sector into a buffer
	while (retry < 10)
    1030:	c9 f7       	brne	.-14     	; 0x1024 <get_set_next_cluster+0x9c>
		}		
		retry++;
	}
	
	// get the cluster address from the buffer
	FAT_entry_value = (unsigned long *) &buffer[FAT_entry_offset];
    1032:	f8 01       	movw	r30, r16
    1034:	e0 58       	subi	r30, 0x80	; 128
    1036:	fb 4f       	sbci	r31, 0xFB	; 251
	
	if (get_set == GET)
    1038:	33 20       	and	r3, r3
    103a:	31 f4       	brne	.+12     	; 0x1048 <get_set_next_cluster+0xc0>
	{
		return ((*FAT_entry_value) & 0x0FFFFFFF);
    103c:	00 81       	ld	r16, Z
    103e:	11 81       	ldd	r17, Z+1	; 0x01
    1040:	22 81       	ldd	r18, Z+2	; 0x02
    1042:	33 81       	ldd	r19, Z+3	; 0x03
    1044:	3f 70       	andi	r19, 0x0F	; 15
    1046:	0c c0       	rjmp	.+24     	; 0x1060 <get_set_next_cluster+0xd8>
	}
	
	// for setting new value in cluster entry in FAT
	*FAT_entry_value = cluster_entry;
    1048:	89 81       	ldd	r24, Y+1	; 0x01
    104a:	9a 81       	ldd	r25, Y+2	; 0x02
    104c:	ab 81       	ldd	r26, Y+3	; 0x03
    104e:	bc 81       	ldd	r27, Y+4	; 0x04
    1050:	80 83       	st	Z, r24
    1052:	91 83       	std	Z+1, r25	; 0x01
    1054:	a2 83       	std	Z+2, r26	; 0x02
    1056:	b3 83       	std	Z+3, r27	; 0x03
	
	return 1;
    1058:	01 e0       	ldi	r16, 0x01	; 1
    105a:	10 e0       	ldi	r17, 0x00	; 0
    105c:	20 e0       	ldi	r18, 0x00	; 0
    105e:	30 e0       	ldi	r19, 0x00	; 0
}
    1060:	60 2f       	mov	r22, r16
    1062:	71 2f       	mov	r23, r17
    1064:	82 2f       	mov	r24, r18
    1066:	93 2f       	mov	r25, r19
    1068:	0f 90       	pop	r0
    106a:	0f 90       	pop	r0
    106c:	0f 90       	pop	r0
    106e:	0f 90       	pop	r0
    1070:	df 91       	pop	r29
    1072:	cf 91       	pop	r28
    1074:	1f 91       	pop	r17
    1076:	0f 91       	pop	r16
    1078:	ff 90       	pop	r15
    107a:	ef 90       	pop	r14
    107c:	df 90       	pop	r13
    107e:	cf 90       	pop	r12
    1080:	bf 90       	pop	r11
    1082:	af 90       	pop	r10
    1084:	9f 90       	pop	r9
    1086:	8f 90       	pop	r8
    1088:	7f 90       	pop	r7
    108a:	6f 90       	pop	r6
    108c:	5f 90       	pop	r5
    108e:	4f 90       	pop	r4
    1090:	3f 90       	pop	r3
    1092:	08 95       	ret

00001094 <convert_file_name>:


// to convert normal short file name into FAT format
unsigned char convert_file_name(unsigned char *file_name)
{
    1094:	cf 93       	push	r28
    1096:	df 93       	push	r29
    1098:	cd b7       	in	r28, 0x3d	; 61
    109a:	de b7       	in	r29, 0x3e	; 62
    109c:	2b 97       	sbiw	r28, 0x0b	; 11
    109e:	0f b6       	in	r0, 0x3f	; 63
    10a0:	f8 94       	cli
    10a2:	de bf       	out	0x3e, r29	; 62
    10a4:	0f be       	out	0x3f, r0	; 63
    10a6:	cd bf       	out	0x3d, r28	; 61
    10a8:	9c 01       	movw	r18, r24
	unsigned char file_name_FAT[11], j, k;
	
	for (j = 0; j < 12; j++)
	{
		if (file_name[j] == '.')
    10aa:	fc 01       	movw	r30, r24
    10ac:	80 81       	ld	r24, Z
    10ae:	8e 32       	cpi	r24, 0x2E	; 46
    10b0:	09 f4       	brne	.+2      	; 0x10b4 <convert_file_name+0x20>
    10b2:	66 c0       	rjmp	.+204    	; 0x1180 <convert_file_name+0xec>
	return 1;
}


// to convert normal short file name into FAT format
unsigned char convert_file_name(unsigned char *file_name)
    10b4:	31 96       	adiw	r30, 0x01	; 1
{
	unsigned char file_name_FAT[11], j, k;
	
	for (j = 0; j < 12; j++)
    10b6:	41 e0       	ldi	r20, 0x01	; 1
	{
		if (file_name[j] == '.')
    10b8:	81 91       	ld	r24, Z+
    10ba:	8e 32       	cpi	r24, 0x2E	; 46
    10bc:	21 f0       	breq	.+8      	; 0x10c6 <convert_file_name+0x32>
// to convert normal short file name into FAT format
unsigned char convert_file_name(unsigned char *file_name)
{
	unsigned char file_name_FAT[11], j, k;
	
	for (j = 0; j < 12; j++)
    10be:	4f 5f       	subi	r20, 0xFF	; 255
    10c0:	4c 30       	cpi	r20, 0x0C	; 12
    10c2:	d1 f7       	brne	.-12     	; 0x10b8 <convert_file_name+0x24>
    10c4:	03 c0       	rjmp	.+6      	; 0x10cc <convert_file_name+0x38>
		//lcd_string(1, 1, "invalid filename");
		//_delay_ms(500);
	}
	
	// setting file name
	for (k = 0; k < j; k++)
    10c6:	44 23       	and	r20, r20
    10c8:	09 f4       	brne	.+2      	; 0x10cc <convert_file_name+0x38>
    10ca:	5b c0       	rjmp	.+182    	; 0x1182 <convert_file_name+0xee>
    10cc:	d9 01       	movw	r26, r18
    10ce:	fe 01       	movw	r30, r28
    10d0:	31 96       	adiw	r30, 0x01	; 1
	return 1;
}


// to convert normal short file name into FAT format
unsigned char convert_file_name(unsigned char *file_name)
    10d2:	84 2f       	mov	r24, r20
    10d4:	81 50       	subi	r24, 0x01	; 1
    10d6:	62 e0       	ldi	r22, 0x02	; 2
    10d8:	70 e0       	ldi	r23, 0x00	; 0
    10da:	6c 0f       	add	r22, r28
    10dc:	7d 1f       	adc	r23, r29
    10de:	68 0f       	add	r22, r24
    10e0:	71 1d       	adc	r23, r1
    10e2:	cb 01       	movw	r24, r22
	}
	
	// setting file name
	for (k = 0; k < j; k++)
	{
		file_name_FAT[k] = file_name[k];
    10e4:	5d 91       	ld	r21, X+
    10e6:	51 93       	st	Z+, r21
		//lcd_string(1, 1, "invalid filename");
		//_delay_ms(500);
	}
	
	// setting file name
	for (k = 0; k < j; k++)
    10e8:	e8 17       	cp	r30, r24
    10ea:	f9 07       	cpc	r31, r25
    10ec:	d9 f7       	brne	.-10     	; 0x10e4 <convert_file_name+0x50>
	{
		file_name_FAT[k] = file_name[k];
	}
	
	// filling file name trail with blanks
	for (k = j; k <= 7; k++)
    10ee:	48 30       	cpi	r20, 0x08	; 8
    10f0:	08 f4       	brcc	.+2      	; 0x10f4 <convert_file_name+0x60>
    10f2:	49 c0       	rjmp	.+146    	; 0x1186 <convert_file_name+0xf2>
    10f4:	0b c0       	rjmp	.+22     	; 0x110c <convert_file_name+0x78>
	{
		file_name_FAT[k] = ' ';
    10f6:	90 e2       	ldi	r25, 0x20	; 32
    10f8:	e1 e0       	ldi	r30, 0x01	; 1
    10fa:	f0 e0       	ldi	r31, 0x00	; 0
    10fc:	ec 0f       	add	r30, r28
    10fe:	fd 1f       	adc	r31, r29
    1100:	e8 0f       	add	r30, r24
    1102:	f1 1d       	adc	r31, r1
    1104:	90 83       	st	Z, r25
	{
		file_name_FAT[k] = file_name[k];
	}
	
	// filling file name trail with blanks
	for (k = j; k <= 7; k++)
    1106:	8f 5f       	subi	r24, 0xFF	; 255
    1108:	88 30       	cpi	r24, 0x08	; 8
    110a:	b0 f3       	brcs	.-20     	; 0x10f8 <convert_file_name+0x64>
	{
		file_name_FAT[k] = ' ';
	}
	
	j++;
    110c:	84 2f       	mov	r24, r20
    110e:	8f 5f       	subi	r24, 0xFF	; 255
	
	// setting file extension
	for (k = 8; k < 11; k++)
	{
		if (file_name[j] != 0)
    1110:	f9 01       	movw	r30, r18
    1112:	e8 0f       	add	r30, r24
    1114:	f1 1d       	adc	r31, r1
    1116:	80 81       	ld	r24, Z
    1118:	88 23       	and	r24, r24
    111a:	b9 f1       	breq	.+110    	; 0x118a <convert_file_name+0xf6>
		{
			file_name_FAT[k] = file_name[j++];
    111c:	89 87       	std	Y+9, r24	; 0x09
    111e:	84 2f       	mov	r24, r20
    1120:	8e 5f       	subi	r24, 0xFE	; 254
	j++;
	
	// setting file extension
	for (k = 8; k < 11; k++)
	{
		if (file_name[j] != 0)
    1122:	f9 01       	movw	r30, r18
    1124:	e8 0f       	add	r30, r24
    1126:	f1 1d       	adc	r31, r1
    1128:	80 81       	ld	r24, Z
    112a:	88 23       	and	r24, r24
    112c:	71 f1       	breq	.+92     	; 0x118a <convert_file_name+0xf6>
		{
			file_name_FAT[k] = file_name[j++];
    112e:	8a 87       	std	Y+10, r24	; 0x0a
    1130:	4d 5f       	subi	r20, 0xFD	; 253
	j++;
	
	// setting file extension
	for (k = 8; k < 11; k++)
	{
		if (file_name[j] != 0)
    1132:	f9 01       	movw	r30, r18
    1134:	e4 0f       	add	r30, r20
    1136:	f1 1d       	adc	r31, r1
    1138:	80 81       	ld	r24, Z
    113a:	88 23       	and	r24, r24
    113c:	31 f1       	breq	.+76     	; 0x118a <convert_file_name+0xf6>
		{
			file_name_FAT[k] = file_name[j++];
    113e:	8b 87       	std	Y+11, r24	; 0x0b
    1140:	fe 01       	movw	r30, r28
    1142:	31 96       	adiw	r30, 0x01	; 1
	return 1;
}


// to convert normal short file name into FAT format
unsigned char convert_file_name(unsigned char *file_name)
    1144:	ce 01       	movw	r24, r28
    1146:	0c 96       	adiw	r24, 0x0c	; 12
    1148:	df 01       	movw	r26, r30
	}
	
	// converting small letters to caps
	for (j = 0; j < 11; j++)
	{
		if ((file_name_FAT[j] >= 0x61) && file_name_FAT[j] <= 0x7A)
    114a:	4c 91       	ld	r20, X
    114c:	54 2f       	mov	r21, r20
    114e:	51 56       	subi	r21, 0x61	; 97
    1150:	5a 31       	cpi	r21, 0x1A	; 26
    1152:	10 f4       	brcc	.+4      	; 0x1158 <convert_file_name+0xc4>
		{
			file_name_FAT[j] = file_name_FAT[j] - 0x20;
    1154:	40 52       	subi	r20, 0x20	; 32
    1156:	4c 93       	st	X, r20
    1158:	11 96       	adiw	r26, 0x01	; 1
			}
		}
	}
	
	// converting small letters to caps
	for (j = 0; j < 11; j++)
    115a:	a8 17       	cp	r26, r24
    115c:	b9 07       	cpc	r27, r25
    115e:	a9 f7       	brne	.-22     	; 0x114a <convert_file_name+0xb6>
    1160:	d9 01       	movw	r26, r18
		}
	}
	
	for (j = 0; j < 11; j++)
	{
		file_name[j] = file_name_FAT[j];
    1162:	21 91       	ld	r18, Z+
    1164:	2d 93       	st	X+, r18
		{
			file_name_FAT[j] = file_name_FAT[j] - 0x20;
		}
	}
	
	for (j = 0; j < 11; j++)
    1166:	8e 17       	cp	r24, r30
    1168:	9f 07       	cpc	r25, r31
    116a:	d9 f7       	brne	.-10     	; 0x1162 <convert_file_name+0xce>
	{
		file_name[j] = file_name_FAT[j];
	}
	
	return 1;
}
    116c:	81 e0       	ldi	r24, 0x01	; 1
    116e:	2b 96       	adiw	r28, 0x0b	; 11
    1170:	0f b6       	in	r0, 0x3f	; 63
    1172:	f8 94       	cli
    1174:	de bf       	out	0x3e, r29	; 62
    1176:	0f be       	out	0x3f, r0	; 63
    1178:	cd bf       	out	0x3d, r28	; 61
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	08 95       	ret
// to convert normal short file name into FAT format
unsigned char convert_file_name(unsigned char *file_name)
{
	unsigned char file_name_FAT[11], j, k;
	
	for (j = 0; j < 12; j++)
    1180:	40 e0       	ldi	r20, 0x00	; 0
    1182:	84 2f       	mov	r24, r20
    1184:	b8 cf       	rjmp	.-144    	; 0x10f6 <convert_file_name+0x62>
	{
		file_name_FAT[k] = file_name[k];
	}
	
	// filling file name trail with blanks
	for (k = j; k <= 7; k++)
    1186:	84 2f       	mov	r24, r20
    1188:	b6 cf       	rjmp	.-148    	; 0x10f6 <convert_file_name+0x62>
    118a:	ff cf       	rjmp	.-2      	; 0x118a <convert_file_name+0xf6>

0000118c <get_first_sector>:
}


// to calculate first sector address of any given cluster number
unsigned long get_first_sector(unsigned long cluster_number)
{
    118c:	0f 93       	push	r16
    118e:	1f 93       	push	r17
	return (first_data_sector + ((cluster_number - 2) * sectors_per_cluster));
    1190:	62 50       	subi	r22, 0x02	; 2
    1192:	70 40       	sbci	r23, 0x00	; 0
    1194:	80 40       	sbci	r24, 0x00	; 0
    1196:	90 40       	sbci	r25, 0x00	; 0
    1198:	20 91 77 04 	lds	r18, 0x0477
    119c:	30 e0       	ldi	r19, 0x00	; 0
    119e:	40 e0       	ldi	r20, 0x00	; 0
    11a0:	50 e0       	ldi	r21, 0x00	; 0
    11a2:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <__mulsi3>
    11a6:	8b 01       	movw	r16, r22
    11a8:	9c 01       	movw	r18, r24
    11aa:	80 91 89 06 	lds	r24, 0x0689
    11ae:	90 91 8a 06 	lds	r25, 0x068A
    11b2:	a0 91 8b 06 	lds	r26, 0x068B
    11b6:	b0 91 8c 06 	lds	r27, 0x068C
    11ba:	08 0f       	add	r16, r24
    11bc:	19 1f       	adc	r17, r25
    11be:	2a 1f       	adc	r18, r26
    11c0:	3b 1f       	adc	r19, r27
}
    11c2:	60 2f       	mov	r22, r16
    11c4:	71 2f       	mov	r23, r17
    11c6:	82 2f       	mov	r24, r18
    11c8:	93 2f       	mov	r25, r19
    11ca:	1f 91       	pop	r17
    11cc:	0f 91       	pop	r16
    11ce:	08 95       	ret

000011d0 <find_file>:


// to get DIR/FILE list
struct DIR_info* find_file(unsigned char flag, unsigned char *file_name)
{
    11d0:	2f 92       	push	r2
    11d2:	3f 92       	push	r3
    11d4:	4f 92       	push	r4
    11d6:	5f 92       	push	r5
    11d8:	6f 92       	push	r6
    11da:	7f 92       	push	r7
    11dc:	8f 92       	push	r8
    11de:	9f 92       	push	r9
    11e0:	af 92       	push	r10
    11e2:	bf 92       	push	r11
    11e4:	cf 92       	push	r12
    11e6:	df 92       	push	r13
    11e8:	ef 92       	push	r14
    11ea:	ff 92       	push	r15
    11ec:	0f 93       	push	r16
    11ee:	1f 93       	push	r17
    11f0:	cf 93       	push	r28
    11f2:	df 93       	push	r29
    11f4:	cd b7       	in	r28, 0x3d	; 61
    11f6:	de b7       	in	r29, 0x3e	; 62
    11f8:	29 97       	sbiw	r28, 0x09	; 9
    11fa:	0f b6       	in	r0, 0x3f	; 63
    11fc:	f8 94       	cli
    11fe:	de bf       	out	0x3e, r29	; 62
    1200:	0f be       	out	0x3f, r0	; 63
    1202:	cd bf       	out	0x3d, r28	; 61
    1204:	f8 2e       	mov	r15, r24
    1206:	6b 01       	movw	r12, r22
	unsigned long cluster, sector, first_sector; //, first_cluster, next_cluster;
	struct DIR_info *dir_info_sector;
	unsigned int i;
	unsigned char j;
	
	cluster = root_cluster;
    1208:	80 91 85 06 	lds	r24, 0x0685
    120c:	90 91 86 06 	lds	r25, 0x0686
    1210:	a0 91 87 06 	lds	r26, 0x0687
    1214:	b0 91 88 06 	lds	r27, 0x0688
    1218:	8c 83       	std	Y+4, r24	; 0x04
    121a:	9d 83       	std	Y+5, r25	; 0x05
    121c:	ae 83       	std	Y+6, r26	; 0x06
    121e:	bf 83       	std	Y+7, r27	; 0x07
		
		for (sector = 0; sector < sectors_per_cluster; sector++)
		{
			read_single_block(first_sector + sector);
			
			for (i = 0; i < bytes_per_sector; i += 32)
    1220:	80 e8       	ldi	r24, 0x80	; 128
    1222:	94 e0       	ldi	r25, 0x04	; 4
    1224:	e8 2e       	mov	r14, r24
    1226:	9b 83       	std	Y+3, r25	; 0x03
    1228:	dc 01       	movw	r26, r24
    122a:	1b 96       	adiw	r26, 0x0b	; 11
    122c:	ba 83       	std	Y+2, r27	; 0x02
    122e:	a9 83       	std	Y+1, r26	; 0x01
	return (first_data_sector + ((cluster_number - 2) * sectors_per_cluster));
}


// to get DIR/FILE list
struct DIR_info* find_file(unsigned char flag, unsigned char *file_name)
    1230:	3b 01       	movw	r6, r22
    1232:	08 94       	sec
    1234:	61 1c       	adc	r6, r1
    1236:	71 1c       	adc	r7, r1
	
	cluster = root_cluster;
	
	while (1)
	{
		first_sector = get_first_sector(cluster);
    1238:	6c 81       	ldd	r22, Y+4	; 0x04
    123a:	7d 81       	ldd	r23, Y+5	; 0x05
    123c:	8e 81       	ldd	r24, Y+6	; 0x06
    123e:	9f 81       	ldd	r25, Y+7	; 0x07
    1240:	0e 94 c6 08 	call	0x118c	; 0x118c <get_first_sector>
    1244:	1b 01       	movw	r2, r22
    1246:	2c 01       	movw	r4, r24
		
		for (sector = 0; sector < sectors_per_cluster; sector++)
    1248:	80 91 77 04 	lds	r24, 0x0477
    124c:	88 23       	and	r24, r24
    124e:	09 f4       	brne	.+2      	; 0x1252 <find_file+0x82>
    1250:	ab c0       	rjmp	.+342    	; 0x13a8 <find_file+0x1d8>
    1252:	88 24       	eor	r8, r8
    1254:	99 24       	eor	r9, r9
    1256:	54 01       	movw	r10, r8
	return (first_data_sector + ((cluster_number - 2) * sectors_per_cluster));
}


// to get DIR/FILE list
struct DIR_info* find_file(unsigned char flag, unsigned char *file_name)
    1258:	c4 01       	movw	r24, r8
    125a:	82 0d       	add	r24, r2
    125c:	93 1d       	adc	r25, r3
	{
		first_sector = get_first_sector(cluster);
		
		for (sector = 0; sector < sectors_per_cluster; sector++)
		{
			read_single_block(first_sector + sector);
    125e:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <read_single_block>
			
			for (i = 0; i < bytes_per_sector; i += 32)
    1262:	00 91 5b 02 	lds	r16, 0x025B
    1266:	10 91 5c 02 	lds	r17, 0x025C
    126a:	01 15       	cp	r16, r1
    126c:	11 05       	cpc	r17, r1
    126e:	09 f4       	brne	.+2      	; 0x1272 <find_file+0xa2>
    1270:	8b c0       	rjmp	.+278    	; 0x1388 <find_file+0x1b8>
    1272:	ae 2d       	mov	r26, r14
    1274:	bb 81       	ldd	r27, Y+3	; 0x03
    1276:	89 81       	ldd	r24, Y+1	; 0x01
    1278:	9a 81       	ldd	r25, Y+2	; 0x02
    127a:	20 e0       	ldi	r18, 0x00	; 0
    127c:	30 e0       	ldi	r19, 0x00	; 0
    127e:	99 87       	std	Y+9, r25	; 0x09
    1280:	88 87       	std	Y+8, r24	; 0x08
    1282:	c8 01       	movw	r24, r16
    1284:	0f 2d       	mov	r16, r15
    1286:	7c 01       	movw	r14, r24
    1288:	1a 2f       	mov	r17, r26
			{
				dir_info_sector = (struct DIR_info *) &buffer[i];
    128a:	bd 01       	movw	r22, r26
				//lcd_clear();
				//lcd_wr_char(1, 1, dir_info_sector->name[0]);
				//lcd_numeric_value(2, 1, dir_info_sector->name[0], 5);
				//_delay_ms(500);
				
				if (dir_info_sector->name[0] == EMPTY)
    128c:	8c 91       	ld	r24, X
    128e:	88 23       	and	r24, r24
    1290:	19 f4       	brne	.+6      	; 0x1298 <find_file+0xc8>
				{
					if (flag == GET_FILE)
    1292:	01 30       	cpi	r16, 0x01	; 1
    1294:	21 f4       	brne	.+8      	; 0x129e <find_file+0xce>
    1296:	a2 c0       	rjmp	.+324    	; 0x13dc <find_file+0x20c>
					}
				}
				
				//lcd_clear();
				
				if ((dir_info_sector->name[0] != DELETED) && dir_info_sector->attrib != ATTR_LONG_NAME)
    1298:	85 3e       	cpi	r24, 0xE5	; 229
    129a:	09 f4       	brne	.+2      	; 0x129e <find_file+0xce>
    129c:	67 c0       	rjmp	.+206    	; 0x136c <find_file+0x19c>
    129e:	e8 85       	ldd	r30, Y+8	; 0x08
    12a0:	f9 85       	ldd	r31, Y+9	; 0x09
    12a2:	90 81       	ld	r25, Z
    12a4:	9f 30       	cpi	r25, 0x0F	; 15
    12a6:	09 f4       	brne	.+2      	; 0x12aa <find_file+0xda>
    12a8:	61 c0       	rjmp	.+194    	; 0x136c <find_file+0x19c>
				{
					if (flag == GET_FILE)
    12aa:	01 30       	cpi	r16, 0x01	; 1
    12ac:	09 f0       	breq	.+2      	; 0x12b0 <find_file+0xe0>
    12ae:	5e c0       	rjmp	.+188    	; 0x136c <find_file+0x19c>
							//lcd_wr_char(1, j+1, dir_info_sector->name[j]);
							//lcd_numeric_value(2, 1, i, 5);
							//lcd_numeric_value(2, 8, j, 3);
							//_delay_ms(500);
							
							if (dir_info_sector->name[j] != file_name[j])
    12b0:	f6 01       	movw	r30, r12
    12b2:	90 81       	ld	r25, Z
    12b4:	89 17       	cp	r24, r25
    12b6:	09 f4       	brne	.+2      	; 0x12ba <find_file+0xea>
    12b8:	4e c0       	rjmp	.+156    	; 0x1356 <find_file+0x186>
    12ba:	58 c0       	rjmp	.+176    	; 0x136c <find_file+0x19c>
    12bc:	ca 01       	movw	r24, r20
    12be:	ad 01       	movw	r20, r26
    12c0:	dc 01       	movw	r26, r24
    12c2:	91 91       	ld	r25, Z+
    12c4:	8d 91       	ld	r24, X+
    12c6:	98 17       	cp	r25, r24
    12c8:	09 f0       	breq	.+2      	; 0x12cc <find_file+0xfc>
    12ca:	4f c0       	rjmp	.+158    	; 0x136a <find_file+0x19a>
							{
								break;
							}
							
							if (j == 10)
    12cc:	88 85       	ldd	r24, Y+8	; 0x08
    12ce:	99 85       	ldd	r25, Y+9	; 0x09
    12d0:	e8 17       	cp	r30, r24
    12d2:	f9 07       	cpc	r31, r25
    12d4:	b1 f7       	brne	.-20     	; 0x12c2 <find_file+0xf2>
								lcd_string(2, 1, "file exists");
								_delay_ms(500);
								*/
								if (flag == GET_FILE)
								{
									append_file_sector = first_sector + sector;
    12d6:	82 0c       	add	r8, r2
    12d8:	93 1c       	adc	r9, r3
    12da:	a4 1c       	adc	r10, r4
    12dc:	b5 1c       	adc	r11, r5
    12de:	80 92 73 04 	sts	0x0473, r8
    12e2:	90 92 74 04 	sts	0x0474, r9
    12e6:	a0 92 75 04 	sts	0x0475, r10
    12ea:	b0 92 76 04 	sts	0x0476, r11
									append_file_location = i;
    12ee:	c9 01       	movw	r24, r18
    12f0:	a0 e0       	ldi	r26, 0x00	; 0
    12f2:	b0 e0       	ldi	r27, 0x00	; 0
    12f4:	80 93 6b 04 	sts	0x046B, r24
    12f8:	90 93 6c 04 	sts	0x046C, r25
    12fc:	a0 93 6d 04 	sts	0x046D, r26
    1300:	b0 93 6e 04 	sts	0x046E, r27
									append_start_cluster = (((unsigned long) dir_info_sector->first_cluster_high) << 16) | dir_info_sector->first_cluster_low;
    1304:	db 01       	movw	r26, r22
    1306:	54 96       	adiw	r26, 0x14	; 20
    1308:	8d 91       	ld	r24, X+
    130a:	9c 91       	ld	r25, X
    130c:	55 97       	sbiw	r26, 0x15	; 21
    130e:	a0 e0       	ldi	r26, 0x00	; 0
    1310:	b0 e0       	ldi	r27, 0x00	; 0
    1312:	dc 01       	movw	r26, r24
    1314:	99 27       	eor	r25, r25
    1316:	88 27       	eor	r24, r24
    1318:	fb 01       	movw	r30, r22
    131a:	22 8d       	ldd	r18, Z+26	; 0x1a
    131c:	33 8d       	ldd	r19, Z+27	; 0x1b
    131e:	89 01       	movw	r16, r18
    1320:	20 e0       	ldi	r18, 0x00	; 0
    1322:	30 e0       	ldi	r19, 0x00	; 0
    1324:	80 2b       	or	r24, r16
    1326:	91 2b       	or	r25, r17
    1328:	a2 2b       	or	r26, r18
    132a:	b3 2b       	or	r27, r19
    132c:	80 93 78 04 	sts	0x0478, r24
    1330:	90 93 79 04 	sts	0x0479, r25
    1334:	a0 93 7a 04 	sts	0x047A, r26
    1338:	b0 93 7b 04 	sts	0x047B, r27
									file_size = dir_info_sector->file_size;
    133c:	84 8d       	ldd	r24, Z+28	; 0x1c
    133e:	95 8d       	ldd	r25, Z+29	; 0x1d
    1340:	a6 8d       	ldd	r26, Z+30	; 0x1e
    1342:	b7 8d       	ldd	r27, Z+31	; 0x1f
    1344:	80 93 90 06 	sts	0x0690, r24
    1348:	90 93 91 06 	sts	0x0691, r25
    134c:	a0 93 92 06 	sts	0x0692, r26
    1350:	b0 93 93 06 	sts	0x0693, r27
									//lcd_clear();
									//lcd_numeric_value(1, 1, file_size, 5);
									//lcd_numeric_value(2, 1, append_file_sector, 5);
									//_delay_ms(500);
									
									return dir_info_sector;
    1354:	45 c0       	rjmp	.+138    	; 0x13e0 <find_file+0x210>
	return (first_data_sector + ((cluster_number - 2) * sectors_per_cluster));
}


// to get DIR/FILE list
struct DIR_info* find_file(unsigned char flag, unsigned char *file_name)
    1356:	fb 01       	movw	r30, r22
    1358:	31 96       	adiw	r30, 0x01	; 1
    135a:	a3 01       	movw	r20, r6
				
				if ((dir_info_sector->name[0] != DELETED) && dir_info_sector->attrib != ATTR_LONG_NAME)
				{
					if (flag == GET_FILE)
					{
						for (j = 0; j < 11; j++)
    135c:	88 85       	ldd	r24, Y+8	; 0x08
    135e:	99 85       	ldd	r25, Y+9	; 0x09
    1360:	8e 17       	cp	r24, r30
    1362:	9f 07       	cpc	r25, r31
    1364:	09 f0       	breq	.+2      	; 0x1368 <find_file+0x198>
    1366:	aa cf       	rjmp	.-172    	; 0x12bc <find_file+0xec>
    1368:	01 c0       	rjmp	.+2      	; 0x136c <find_file+0x19c>
    136a:	da 01       	movw	r26, r20
		
		for (sector = 0; sector < sectors_per_cluster; sector++)
		{
			read_single_block(first_sector + sector);
			
			for (i = 0; i < bytes_per_sector; i += 32)
    136c:	20 5e       	subi	r18, 0xE0	; 224
    136e:	3f 4f       	sbci	r19, 0xFF	; 255
    1370:	90 96       	adiw	r26, 0x20	; 32
    1372:	88 85       	ldd	r24, Y+8	; 0x08
    1374:	99 85       	ldd	r25, Y+9	; 0x09
    1376:	80 96       	adiw	r24, 0x20	; 32
    1378:	99 87       	std	Y+9, r25	; 0x09
    137a:	88 87       	std	Y+8, r24	; 0x08
    137c:	2e 15       	cp	r18, r14
    137e:	3f 05       	cpc	r19, r15
    1380:	08 f4       	brcc	.+2      	; 0x1384 <find_file+0x1b4>
    1382:	83 cf       	rjmp	.-250    	; 0x128a <find_file+0xba>
    1384:	f0 2e       	mov	r15, r16
    1386:	e1 2e       	mov	r14, r17
	
	while (1)
	{
		first_sector = get_first_sector(cluster);
		
		for (sector = 0; sector < sectors_per_cluster; sector++)
    1388:	08 94       	sec
    138a:	81 1c       	adc	r8, r1
    138c:	91 1c       	adc	r9, r1
    138e:	a1 1c       	adc	r10, r1
    1390:	b1 1c       	adc	r11, r1
    1392:	80 91 77 04 	lds	r24, 0x0477
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	a0 e0       	ldi	r26, 0x00	; 0
    139a:	b0 e0       	ldi	r27, 0x00	; 0
    139c:	88 16       	cp	r8, r24
    139e:	99 06       	cpc	r9, r25
    13a0:	aa 06       	cpc	r10, r26
    13a2:	bb 06       	cpc	r11, r27
    13a4:	08 f4       	brcc	.+2      	; 0x13a8 <find_file+0x1d8>
    13a6:	58 cf       	rjmp	.-336    	; 0x1258 <find_file+0x88>
					}
				}
			}
		}
		
		cluster = get_set_next_cluster(GET, cluster, 0);
    13a8:	80 e0       	ldi	r24, 0x00	; 0
    13aa:	4c 81       	ldd	r20, Y+4	; 0x04
    13ac:	5d 81       	ldd	r21, Y+5	; 0x05
    13ae:	6e 81       	ldd	r22, Y+6	; 0x06
    13b0:	7f 81       	ldd	r23, Y+7	; 0x07
    13b2:	00 e0       	ldi	r16, 0x00	; 0
    13b4:	10 e0       	ldi	r17, 0x00	; 0
    13b6:	98 01       	movw	r18, r16
    13b8:	0e 94 c4 07 	call	0xf88	; 0xf88 <get_set_next_cluster>
    13bc:	6c 83       	std	Y+4, r22	; 0x04
    13be:	7d 83       	std	Y+5, r23	; 0x05
    13c0:	8e 83       	std	Y+6, r24	; 0x06
    13c2:	9f 83       	std	Y+7, r25	; 0x07
		
		if (cluster > 0x0FFFFFF6)
    13c4:	67 3f       	cpi	r22, 0xF7	; 247
    13c6:	af ef       	ldi	r26, 0xFF	; 255
    13c8:	7a 07       	cpc	r23, r26
    13ca:	af ef       	ldi	r26, 0xFF	; 255
    13cc:	8a 07       	cpc	r24, r26
    13ce:	af e0       	ldi	r26, 0x0F	; 15
    13d0:	9a 07       	cpc	r25, r26
    13d2:	08 f4       	brcc	.+2      	; 0x13d6 <find_file+0x206>
    13d4:	31 cf       	rjmp	.-414    	; 0x1238 <find_file+0x68>
		{
			return 0;
    13d6:	60 e0       	ldi	r22, 0x00	; 0
    13d8:	70 e0       	ldi	r23, 0x00	; 0
    13da:	02 c0       	rjmp	.+4      	; 0x13e0 <find_file+0x210>
					if (flag == GET_FILE)
					{
						//lcd_clear();
						//lcd_string(1, 1, "file not exist");
						//_delay_ms(500);
						return 0;
    13dc:	60 e0       	ldi	r22, 0x00	; 0
    13de:	70 e0       	ldi	r23, 0x00	; 0
			return 0;
		}
	}
	
	return 0;
}
    13e0:	86 2f       	mov	r24, r22
    13e2:	97 2f       	mov	r25, r23
    13e4:	29 96       	adiw	r28, 0x09	; 9
    13e6:	0f b6       	in	r0, 0x3f	; 63
    13e8:	f8 94       	cli
    13ea:	de bf       	out	0x3e, r29	; 62
    13ec:	0f be       	out	0x3f, r0	; 63
    13ee:	cd bf       	out	0x3d, r28	; 61
    13f0:	df 91       	pop	r29
    13f2:	cf 91       	pop	r28
    13f4:	1f 91       	pop	r17
    13f6:	0f 91       	pop	r16
    13f8:	ff 90       	pop	r15
    13fa:	ef 90       	pop	r14
    13fc:	df 90       	pop	r13
    13fe:	cf 90       	pop	r12
    1400:	bf 90       	pop	r11
    1402:	af 90       	pop	r10
    1404:	9f 90       	pop	r9
    1406:	8f 90       	pop	r8
    1408:	7f 90       	pop	r7
    140a:	6f 90       	pop	r6
    140c:	5f 90       	pop	r5
    140e:	4f 90       	pop	r4
    1410:	3f 90       	pop	r3
    1412:	2f 90       	pop	r2
    1414:	08 95       	ret

00001416 <get_file_info>:


// get the file info (or verify existence of file) from SD card
unsigned char get_file_info(unsigned char flag, unsigned char *file_name)
{
    1416:	1f 93       	push	r17
    1418:	cf 93       	push	r28
    141a:	df 93       	push	r29
    141c:	18 2f       	mov	r17, r24
    141e:	eb 01       	movw	r28, r22
	struct DIR_info *dir_info_sector;
	
	// convert file name to FAT format
	convert_file_name(file_name);
    1420:	cb 01       	movw	r24, r22
    1422:	0e 94 4a 08 	call	0x1094	; 0x1094 <convert_file_name>
	
	dir_info_sector = find_file(GET_FILE, file_name);
    1426:	81 e0       	ldi	r24, 0x01	; 1
    1428:	be 01       	movw	r22, r28
    142a:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <find_file>
    142e:	fc 01       	movw	r30, r24
	
	if (flag == VERIFY)
    1430:	12 30       	cpi	r17, 0x02	; 2
    1432:	61 f1       	breq	.+88     	; 0x148c <get_file_info+0x76>
	{
		return 1;
	}
	
	first_cluster = (((unsigned long) dir_info_sector->first_cluster_high) << 16) | dir_info_sector->first_cluster_low;
    1434:	84 89       	ldd	r24, Z+20	; 0x14
    1436:	95 89       	ldd	r25, Z+21	; 0x15
    1438:	a0 e0       	ldi	r26, 0x00	; 0
    143a:	b0 e0       	ldi	r27, 0x00	; 0
    143c:	dc 01       	movw	r26, r24
    143e:	99 27       	eor	r25, r25
    1440:	88 27       	eor	r24, r24
    1442:	22 8d       	ldd	r18, Z+26	; 0x1a
    1444:	33 8d       	ldd	r19, Z+27	; 0x1b
    1446:	a9 01       	movw	r20, r18
    1448:	60 e0       	ldi	r22, 0x00	; 0
    144a:	70 e0       	ldi	r23, 0x00	; 0
    144c:	84 2b       	or	r24, r20
    144e:	95 2b       	or	r25, r21
    1450:	a6 2b       	or	r26, r22
    1452:	b7 2b       	or	r27, r23
    1454:	80 93 61 02 	sts	0x0261, r24
    1458:	90 93 62 02 	sts	0x0262, r25
    145c:	a0 93 63 02 	sts	0x0263, r26
    1460:	b0 93 64 02 	sts	0x0264, r27
	file_size = dir_info_sector->file_size;
    1464:	84 8d       	ldd	r24, Z+28	; 0x1c
    1466:	95 8d       	ldd	r25, Z+29	; 0x1d
    1468:	a6 8d       	ldd	r26, Z+30	; 0x1e
    146a:	b7 8d       	ldd	r27, Z+31	; 0x1f
    146c:	80 93 90 06 	sts	0x0690, r24
    1470:	90 93 91 06 	sts	0x0691, r25
    1474:	a0 93 92 06 	sts	0x0692, r26
    1478:	b0 93 93 06 	sts	0x0693, r27
	
	curr_pos = 0;
    147c:	10 92 5d 02 	sts	0x025D, r1
    1480:	10 92 5e 02 	sts	0x025E, r1
    1484:	10 92 5f 02 	sts	0x025F, r1
    1488:	10 92 60 02 	sts	0x0260, r1
	
	return 1;
}
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	df 91       	pop	r29
    1490:	cf 91       	pop	r28
    1492:	1f 91       	pop	r17
    1494:	08 95       	ret

00001496 <read_file>:
// read a file from SD card
unsigned char read_file()
{
	unsigned int k;
	
	cluster_start_sector = get_first_sector(first_cluster);
    1496:	60 91 61 02 	lds	r22, 0x0261
    149a:	70 91 62 02 	lds	r23, 0x0262
    149e:	80 91 63 02 	lds	r24, 0x0263
    14a2:	90 91 64 02 	lds	r25, 0x0264
    14a6:	0e 94 c6 08 	call	0x118c	; 0x118c <get_first_sector>
    14aa:	dc 01       	movw	r26, r24
    14ac:	cb 01       	movw	r24, r22
    14ae:	80 93 6f 04 	sts	0x046F, r24
    14b2:	90 93 70 04 	sts	0x0470, r25
    14b6:	a0 93 71 04 	sts	0x0471, r26
    14ba:	b0 93 72 04 	sts	0x0472, r27
	lcd_clear();
	lcd_numeric_value(1, 1, cluster_start_sector, 5);
	lcd_numeric_value(2, 1, file_size, 5);
	_delay_ms(500);*/
	
	block_of_cluster = ((curr_pos >> 9) & (sectors_per_cluster - 1));
    14be:	20 91 77 04 	lds	r18, 0x0477
    14c2:	30 e0       	ldi	r19, 0x00	; 0
    14c4:	21 50       	subi	r18, 0x01	; 1
    14c6:	30 40       	sbci	r19, 0x00	; 0
    14c8:	40 91 5d 02 	lds	r20, 0x025D
    14cc:	50 91 5e 02 	lds	r21, 0x025E
    14d0:	60 91 5f 02 	lds	r22, 0x025F
    14d4:	70 91 60 02 	lds	r23, 0x0260
    14d8:	03 2e       	mov	r0, r19
    14da:	39 e0       	ldi	r19, 0x09	; 9
    14dc:	76 95       	lsr	r23
    14de:	67 95       	ror	r22
    14e0:	57 95       	ror	r21
    14e2:	47 95       	ror	r20
    14e4:	3a 95       	dec	r19
    14e6:	d1 f7       	brne	.-12     	; 0x14dc <read_file+0x46>
    14e8:	30 2d       	mov	r19, r0
    14ea:	24 23       	and	r18, r20
    14ec:	35 23       	and	r19, r21
    14ee:	30 93 8f 06 	sts	0x068F, r19
    14f2:	20 93 8e 06 	sts	0x068E, r18
	
	read_single_block(cluster_start_sector + block_of_cluster);
    14f6:	82 0f       	add	r24, r18
    14f8:	93 1f       	adc	r25, r19
    14fa:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <read_single_block>
	
	curr_pos = curr_pos + bytes_per_sector;
    14fe:	80 91 5b 02 	lds	r24, 0x025B
    1502:	90 91 5c 02 	lds	r25, 0x025C
    1506:	a0 e0       	ldi	r26, 0x00	; 0
    1508:	b0 e0       	ldi	r27, 0x00	; 0
    150a:	40 91 5d 02 	lds	r20, 0x025D
    150e:	50 91 5e 02 	lds	r21, 0x025E
    1512:	60 91 5f 02 	lds	r22, 0x025F
    1516:	70 91 60 02 	lds	r23, 0x0260
    151a:	84 0f       	add	r24, r20
    151c:	95 1f       	adc	r25, r21
    151e:	a6 1f       	adc	r26, r22
    1520:	b7 1f       	adc	r27, r23
    1522:	80 93 5d 02 	sts	0x025D, r24
    1526:	90 93 5e 02 	sts	0x025E, r25
    152a:	a0 93 5f 02 	sts	0x025F, r26
    152e:	b0 93 60 02 	sts	0x0260, r27
	// you may have to get the next cluster if the file size
	// is greater than (bytes_per_sector * sectors_per_cluster)
	//cluster_number = get_set_next_cluster(GET, cluster_number, 0);
	
	return 1;
}
    1532:	81 e0       	ldi	r24, 0x01	; 1
    1534:	08 95       	ret

00001536 <lcd_port_config>:
unsigned int thousand;
unsigned int million;

void lcd_port_config(void)
{
	DDRC = DDRC | 0xF7;		// all LCD pins direction set as output
    1536:	87 b1       	in	r24, 0x07	; 7
    1538:	87 6f       	ori	r24, 0xF7	; 247
    153a:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x08;	// all LCD pins set to logic 0 except PC.3 (Buzzer pin)
    153c:	88 b1       	in	r24, 0x08	; 8
    153e:	88 70       	andi	r24, 0x08	; 8
    1540:	88 b9       	out	0x08, r24	; 8
}
    1542:	08 95       	ret

00001544 <lcd_set_4bit>:
    1544:	86 e6       	ldi	r24, 0x66	; 102
    1546:	9e e0       	ldi	r25, 0x0E	; 14
    1548:	01 97       	sbiw	r24, 0x01	; 1
    154a:	f1 f7       	brne	.-4      	; 0x1548 <lcd_set_4bit+0x4>
    154c:	00 00       	nop
 * Example Call: lcd_set_4bit();
 */
void lcd_set_4bit (void)
{
	_delay_ms(1);
	cbit(lcd_port,RS);				// RS=0 --- Command Input
    154e:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				// RW=0 --- Writing to LCD
    1550:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				// Sending 3
    1552:	80 e3       	ldi	r24, 0x30	; 48
    1554:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				// Set Enable Pin
    1556:	42 9a       	sbi	0x08, 2	; 8
    1558:	ef ef       	ldi	r30, 0xFF	; 255
    155a:	f7 e4       	ldi	r31, 0x47	; 71
    155c:	31 97       	sbiw	r30, 0x01	; 1
    155e:	f1 f7       	brne	.-4      	; 0x155c <lcd_set_4bit+0x18>
    1560:	00 c0       	rjmp	.+0      	; 0x1562 <lcd_set_4bit+0x1e>
    1562:	00 00       	nop
	_delay_ms(5);					// Delay
	cbit(lcd_port,EN);				// Clear Enable Pin
    1564:	42 98       	cbi	0x08, 2	; 8
    1566:	e6 e6       	ldi	r30, 0x66	; 102
    1568:	fe e0       	ldi	r31, 0x0E	; 14
    156a:	31 97       	sbiw	r30, 0x01	; 1
    156c:	f1 f7       	brne	.-4      	; 0x156a <lcd_set_4bit+0x26>
    156e:	00 00       	nop

	_delay_ms(1);
	cbit(lcd_port,RS);				// RS=0 --- Command Input
    1570:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				// RW=0 --- Writing to LCD
    1572:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				// Sending 3
    1574:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				// Set Enable Pin
    1576:	42 9a       	sbi	0x08, 2	; 8
    1578:	ef ef       	ldi	r30, 0xFF	; 255
    157a:	f7 e4       	ldi	r31, 0x47	; 71
    157c:	31 97       	sbiw	r30, 0x01	; 1
    157e:	f1 f7       	brne	.-4      	; 0x157c <lcd_set_4bit+0x38>
    1580:	00 c0       	rjmp	.+0      	; 0x1582 <lcd_set_4bit+0x3e>
    1582:	00 00       	nop
	_delay_ms(5);					// Delay
	cbit(lcd_port,EN);				// Clear Enable Pin
    1584:	42 98       	cbi	0x08, 2	; 8
    1586:	e6 e6       	ldi	r30, 0x66	; 102
    1588:	fe e0       	ldi	r31, 0x0E	; 14
    158a:	31 97       	sbiw	r30, 0x01	; 1
    158c:	f1 f7       	brne	.-4      	; 0x158a <lcd_set_4bit+0x46>
    158e:	00 00       	nop

	_delay_ms(1);
	cbit(lcd_port,RS);				// RS=0 --- Command Input
    1590:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				// RW=0 --- Writing to LCD
    1592:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				// Sending 3
    1594:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				// Set Enable Pin
    1596:	42 9a       	sbi	0x08, 2	; 8
    1598:	8f ef       	ldi	r24, 0xFF	; 255
    159a:	97 e4       	ldi	r25, 0x47	; 71
    159c:	01 97       	sbiw	r24, 0x01	; 1
    159e:	f1 f7       	brne	.-4      	; 0x159c <lcd_set_4bit+0x58>
    15a0:	00 c0       	rjmp	.+0      	; 0x15a2 <lcd_set_4bit+0x5e>
    15a2:	00 00       	nop
	_delay_ms(5);					// Delay
	cbit(lcd_port,EN);				// Clear Enable Pin
    15a4:	42 98       	cbi	0x08, 2	; 8
    15a6:	e6 e6       	ldi	r30, 0x66	; 102
    15a8:	fe e0       	ldi	r31, 0x0E	; 14
    15aa:	31 97       	sbiw	r30, 0x01	; 1
    15ac:	f1 f7       	brne	.-4      	; 0x15aa <lcd_set_4bit+0x66>
    15ae:	00 00       	nop

	_delay_ms(1);
	cbit(lcd_port,RS);				// RS=0 --- Command Input
    15b0:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				// RW=0 --- Writing to LCD
    15b2:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				// Sending 2 to initialize LCD in 4-bit mode
    15b4:	80 e2       	ldi	r24, 0x20	; 32
    15b6:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				// Set Enable Pin
    15b8:	42 9a       	sbi	0x08, 2	; 8
    15ba:	8f ef       	ldi	r24, 0xFF	; 255
    15bc:	97 e4       	ldi	r25, 0x47	; 71
    15be:	01 97       	sbiw	r24, 0x01	; 1
    15c0:	f1 f7       	brne	.-4      	; 0x15be <lcd_set_4bit+0x7a>
    15c2:	00 c0       	rjmp	.+0      	; 0x15c4 <lcd_set_4bit+0x80>
    15c4:	00 00       	nop
	_delay_ms(5);					// Delay
	cbit(lcd_port,EN);				// Clear Enable Pin
    15c6:	42 98       	cbi	0x08, 2	; 8
}
    15c8:	08 95       	ret

000015ca <lcd_wr_command>:
void lcd_wr_command (unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
    15ca:	98 b1       	in	r25, 0x08	; 8
    15cc:	9f 70       	andi	r25, 0x0F	; 15
    15ce:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
    15d0:	98 b1       	in	r25, 0x08	; 8
 */
void lcd_wr_command (unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
    15d2:	28 2f       	mov	r18, r24
    15d4:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
    15d6:	92 2b       	or	r25, r18
    15d8:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
    15da:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
    15dc:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
    15de:	42 9a       	sbi	0x08, 2	; 8
    15e0:	ef ef       	ldi	r30, 0xFF	; 255
    15e2:	f7 e4       	ldi	r31, 0x47	; 71
    15e4:	31 97       	sbiw	r30, 0x01	; 1
    15e6:	f1 f7       	brne	.-4      	; 0x15e4 <lcd_wr_command+0x1a>
    15e8:	00 c0       	rjmp	.+0      	; 0x15ea <lcd_wr_command+0x20>
    15ea:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
    15ec:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
    15ee:	98 b1       	in	r25, 0x08	; 8
    15f0:	9f 70       	andi	r25, 0x0F	; 15
    15f2:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
    15f4:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
    15f6:	82 95       	swap	r24
    15f8:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
    15fa:	89 2b       	or	r24, r25
    15fc:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
    15fe:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
    1600:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
    1602:	42 9a       	sbi	0x08, 2	; 8
    1604:	8f ef       	ldi	r24, 0xFF	; 255
    1606:	97 e4       	ldi	r25, 0x47	; 71
    1608:	01 97       	sbiw	r24, 0x01	; 1
    160a:	f1 f7       	brne	.-4      	; 0x1608 <lcd_wr_command+0x3e>
    160c:	00 c0       	rjmp	.+0      	; 0x160e <lcd_wr_command+0x44>
    160e:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
    1610:	42 98       	cbi	0x08, 2	; 8
}
    1612:	08 95       	ret

00001614 <lcd_init>:
 * Logic: This function initializes the LCD
 * Example Call: lcd_init();
 */
void lcd_init (void)
{
	lcd_set_4bit();
    1614:	0e 94 a2 0a 	call	0x1544	; 0x1544 <lcd_set_4bit>
    1618:	86 e6       	ldi	r24, 0x66	; 102
    161a:	9e e0       	ldi	r25, 0x0E	; 14
    161c:	01 97       	sbiw	r24, 0x01	; 1
    161e:	f1 f7       	brne	.-4      	; 0x161c <lcd_init+0x8>
    1620:	00 00       	nop
	_delay_ms(1);
	lcd_wr_command(0x28);		// LCD 4-bit mode and 2 lines
    1622:	88 e2       	ldi	r24, 0x28	; 40
    1624:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
	lcd_wr_command(0x01);       // Clear display screen
    1628:	81 e0       	ldi	r24, 0x01	; 1
    162a:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
	lcd_wr_command(0x06);       // Entry mode
    162e:	86 e0       	ldi	r24, 0x06	; 6
    1630:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
	lcd_wr_command(0x0E);       // Display On and Cursor On
    1634:	8e e0       	ldi	r24, 0x0E	; 14
    1636:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
	lcd_wr_command(0x80);       // LCD cursor set to Home position		
    163a:	80 e8       	ldi	r24, 0x80	; 128
    163c:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
}
    1640:	08 95       	ret

00001642 <lcd_home>:
 * Logic: Passes 0x80 command to LCD using lcd_wr_command
 * Example Call: lcd_home();
 */
void lcd_home (void)
{
	lcd_wr_command(0x80);		// LCD cursor set to Home position
    1642:	80 e8       	ldi	r24, 0x80	; 128
    1644:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
}
    1648:	08 95       	ret

0000164a <lcd_cursor>:
 *
 * Example Call: lcd_cursor(2, 3);
 */
void lcd_cursor (char row, char column)
{
	switch (row)
    164a:	82 30       	cpi	r24, 0x02	; 2
    164c:	79 f0       	breq	.+30     	; 0x166c <lcd_cursor+0x22>
    164e:	83 30       	cpi	r24, 0x03	; 3
    1650:	18 f4       	brcc	.+6      	; 0x1658 <lcd_cursor+0xe>
    1652:	81 30       	cpi	r24, 0x01	; 1
    1654:	c9 f4       	brne	.+50     	; 0x1688 <lcd_cursor+0x3e>
    1656:	05 c0       	rjmp	.+10     	; 0x1662 <lcd_cursor+0x18>
    1658:	83 30       	cpi	r24, 0x03	; 3
    165a:	69 f0       	breq	.+26     	; 0x1676 <lcd_cursor+0x2c>
    165c:	84 30       	cpi	r24, 0x04	; 4
    165e:	a1 f4       	brne	.+40     	; 0x1688 <lcd_cursor+0x3e>
    1660:	0f c0       	rjmp	.+30     	; 0x1680 <lcd_cursor+0x36>
	{
		case 1: lcd_wr_command (0x80 + column - 1); break;
    1662:	86 2f       	mov	r24, r22
    1664:	81 58       	subi	r24, 0x81	; 129
    1666:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
    166a:	08 95       	ret
		case 2: lcd_wr_command (0xC0 + column - 1); break;
    166c:	86 2f       	mov	r24, r22
    166e:	81 54       	subi	r24, 0x41	; 65
    1670:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
    1674:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
    1676:	86 2f       	mov	r24, r22
    1678:	8d 56       	subi	r24, 0x6D	; 109
    167a:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
    167e:	08 95       	ret
		case 4: lcd_wr_command (0xD4 + column - 1); break;
    1680:	86 2f       	mov	r24, r22
    1682:	8d 52       	subi	r24, 0x2D	; 45
    1684:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
    1688:	08 95       	ret

0000168a <lcd_clear>:
 * Logic: This function clears LCD by giving specific command as input to lcd_wr_command() function
 * Example Call: lcd_clear();
 */
void lcd_clear (void)
{
	lcd_wr_command(0x01);
    168a:	81 e0       	ldi	r24, 0x01	; 1
    168c:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <lcd_wr_command>
}
    1690:	08 95       	ret

00001692 <lcd_wr_char>:
 * Output: None
 * Logic: This function prints an alpha-numeric character at specified (row, column) position on LCD
 * Example Call: lcd_wr_char(1, 4, 'A') => to write character 'A' to the LCD
 */
void lcd_wr_char(char row, char column, char alpha_num_char)
{
    1692:	cf 93       	push	r28
    1694:	c4 2f       	mov	r28, r20
	lcd_cursor (row, column);
    1696:	0e 94 25 0b 	call	0x164a	; 0x164a <lcd_cursor>
	
	char temp;
	temp = alpha_num_char;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
    169a:	88 b1       	in	r24, 0x08	; 8
    169c:	8f 70       	andi	r24, 0x0F	; 15
    169e:	88 b9       	out	0x08, r24	; 8
	lcd_port |= temp;
    16a0:	88 b1       	in	r24, 0x08	; 8
{
	lcd_cursor (row, column);
	
	char temp;
	temp = alpha_num_char;
	temp = (temp & 0xF0);
    16a2:	9c 2f       	mov	r25, r28
    16a4:	90 7f       	andi	r25, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
    16a6:	89 2b       	or	r24, r25
    16a8:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
    16aa:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
    16ac:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
    16ae:	42 9a       	sbi	0x08, 2	; 8
    16b0:	8f ef       	ldi	r24, 0xFF	; 255
    16b2:	97 e4       	ldi	r25, 0x47	; 71
    16b4:	01 97       	sbiw	r24, 0x01	; 1
    16b6:	f1 f7       	brne	.-4      	; 0x16b4 <lcd_wr_char+0x22>
    16b8:	00 c0       	rjmp	.+0      	; 0x16ba <lcd_wr_char+0x28>
    16ba:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
    16bc:	42 98       	cbi	0x08, 2	; 8

	alpha_num_char = alpha_num_char & 0x0F;
	alpha_num_char = alpha_num_char << 4;
	lcd_port &= 0x0F;
    16be:	88 b1       	in	r24, 0x08	; 8
    16c0:	8f 70       	andi	r24, 0x0F	; 15
    16c2:	88 b9       	out	0x08, r24	; 8
	lcd_port |= alpha_num_char;
    16c4:	88 b1       	in	r24, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	alpha_num_char = alpha_num_char & 0x0F;
	alpha_num_char = alpha_num_char << 4;
    16c6:	c2 95       	swap	r28
    16c8:	c0 7f       	andi	r28, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= alpha_num_char;
    16ca:	c8 2b       	or	r28, r24
    16cc:	c8 b9       	out	0x08, r28	; 8
	sbit(lcd_port,RS);
    16ce:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
    16d0:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
    16d2:	42 9a       	sbi	0x08, 2	; 8
    16d4:	8f ef       	ldi	r24, 0xFF	; 255
    16d6:	97 e4       	ldi	r25, 0x47	; 71
    16d8:	01 97       	sbiw	r24, 0x01	; 1
    16da:	f1 f7       	brne	.-4      	; 0x16d8 <lcd_wr_char+0x46>
    16dc:	00 c0       	rjmp	.+0      	; 0x16de <lcd_wr_char+0x4c>
    16de:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
    16e0:	42 98       	cbi	0x08, 2	; 8
}
    16e2:	cf 91       	pop	r28
    16e4:	08 95       	ret

000016e6 <lcd_string>:
 * Output: This function prints the given string on the LCD at the specified (row, column) position
 * Logic: Positions the cursor and prints each character on LCD in a while loop until EOF is reached
 * Example Call: lcd_string(1, 1, "Hello !");
 */
void lcd_string(char row, char column, char *str)
{
    16e6:	0f 93       	push	r16
    16e8:	1f 93       	push	r17
    16ea:	cf 93       	push	r28
    16ec:	df 93       	push	r29
    16ee:	d8 2f       	mov	r29, r24
    16f0:	c6 2f       	mov	r28, r22
    16f2:	fa 01       	movw	r30, r20
	while(*str != '\0')
    16f4:	40 81       	ld	r20, Z
    16f6:	44 23       	and	r20, r20
    16f8:	69 f0       	breq	.+26     	; 0x1714 <lcd_string+0x2e>
 *        *str => pointer of the char data type which points to the address of first character of the string
 * Output: This function prints the given string on the LCD at the specified (row, column) position
 * Logic: Positions the cursor and prints each character on LCD in a while loop until EOF is reached
 * Example Call: lcd_string(1, 1, "Hello !");
 */
void lcd_string(char row, char column, char *str)
    16fa:	8f 01       	movw	r16, r30
    16fc:	0f 5f       	subi	r16, 0xFF	; 255
    16fe:	1f 4f       	sbci	r17, 0xFF	; 255
{
	while(*str != '\0')
	{
		lcd_wr_char(row, column, *str);
    1700:	8d 2f       	mov	r24, r29
    1702:	6c 2f       	mov	r22, r28
    1704:	0e 94 49 0b 	call	0x1692	; 0x1692 <lcd_wr_char>
		str++;
		column+=1;
    1708:	cf 5f       	subi	r28, 0xFF	; 255
 * Logic: Positions the cursor and prints each character on LCD in a while loop until EOF is reached
 * Example Call: lcd_string(1, 1, "Hello !");
 */
void lcd_string(char row, char column, char *str)
{
	while(*str != '\0')
    170a:	f8 01       	movw	r30, r16
    170c:	41 91       	ld	r20, Z+
    170e:	8f 01       	movw	r16, r30
    1710:	44 23       	and	r20, r20
    1712:	b1 f7       	brne	.-20     	; 0x1700 <lcd_string+0x1a>
	{
		lcd_wr_char(row, column, *str);
		str++;
		column+=1;
	}
}
    1714:	df 91       	pop	r29
    1716:	cf 91       	pop	r28
    1718:	1f 91       	pop	r17
    171a:	0f 91       	pop	r16
    171c:	08 95       	ret

0000171e <lcd_numeric_value>:
 * Output: This function prints any integer value or value in a variable as integer
  *        on the specified location and up to the specified number of digits on LCD
 * Example Call: lcd_numeric_value(1, 1, -20, 2);
 */
void lcd_numeric_value(char row, char column, int val, int digits)
{
    171e:	ef 92       	push	r14
    1720:	ff 92       	push	r15
    1722:	0f 93       	push	r16
    1724:	1f 93       	push	r17
    1726:	cf 93       	push	r28
    1728:	df 93       	push	r29
    172a:	d8 2f       	mov	r29, r24
    172c:	c6 2f       	mov	r28, r22
    172e:	7a 01       	movw	r14, r20
    1730:	89 01       	movw	r16, r18
	lcd_cursor(row, column);
    1732:	0e 94 25 0b 	call	0x164a	; 0x164a <lcd_cursor>
	
	if (val < 0)
    1736:	ff 20       	and	r15, r15
    1738:	5c f4       	brge	.+22     	; 0x1750 <lcd_numeric_value+0x32>
	{
		val = 0 - val;
    173a:	f0 94       	com	r15
    173c:	e1 94       	neg	r14
    173e:	f1 08       	sbc	r15, r1
    1740:	f3 94       	inc	r15
		lcd_string(row, column, "-");
    1742:	8d 2f       	mov	r24, r29
    1744:	6c 2f       	mov	r22, r28
    1746:	4a e3       	ldi	r20, 0x3A	; 58
    1748:	52 e0       	ldi	r21, 0x02	; 2
    174a:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <lcd_string>
		column+=1;
    174e:	cf 5f       	subi	r28, 0xFF	; 255
	}
		
	unsigned char flag = 0;
	
	if(row == 0 || column == 0)
    1750:	dd 23       	and	r29, r29
    1752:	11 f0       	breq	.+4      	; 0x1758 <lcd_numeric_value+0x3a>
    1754:	cc 23       	and	r28, r28
    1756:	19 f4       	brne	.+6      	; 0x175e <lcd_numeric_value+0x40>
	{
		lcd_home();
    1758:	0e 94 21 0b 	call	0x1642	; 0x1642 <lcd_home>
    175c:	04 c0       	rjmp	.+8      	; 0x1766 <lcd_numeric_value+0x48>
	}
	
	else
	{
		lcd_cursor(row, column);
    175e:	8d 2f       	mov	r24, r29
    1760:	6c 2f       	mov	r22, r28
    1762:	0e 94 25 0b 	call	0x164a	; 0x164a <lcd_cursor>
	}
	
	if(digits == 5 || flag == 1)
    1766:	05 30       	cpi	r16, 0x05	; 5
    1768:	11 05       	cpc	r17, r1
    176a:	91 f4       	brne	.+36     	; 0x1790 <lcd_numeric_value+0x72>
	{
		million = val/10000+48;
    176c:	c7 01       	movw	r24, r14
    176e:	60 e1       	ldi	r22, 0x10	; 16
    1770:	77 e2       	ldi	r23, 0x27	; 39
    1772:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <__divmodhi4>
    1776:	ab 01       	movw	r20, r22
    1778:	40 5d       	subi	r20, 0xD0	; 208
    177a:	5f 4f       	sbci	r21, 0xFF	; 255
    177c:	50 93 95 06 	sts	0x0695, r21
    1780:	40 93 94 06 	sts	0x0694, r20
		lcd_wr_char(row ,column, million);
    1784:	8d 2f       	mov	r24, r29
    1786:	6c 2f       	mov	r22, r28
    1788:	0e 94 49 0b 	call	0x1692	; 0x1692 <lcd_wr_char>
		column+=1;
    178c:	cf 5f       	subi	r28, 0xFF	; 255
    178e:	03 c0       	rjmp	.+6      	; 0x1796 <lcd_numeric_value+0x78>
		flag = 1;
	}
	
	if(digits == 4 || flag == 1)
    1790:	04 30       	cpi	r16, 0x04	; 4
    1792:	11 05       	cpc	r17, r1
    1794:	e1 f4       	brne	.+56     	; 0x17ce <lcd_numeric_value+0xb0>
	{
		temp = val/1000;
    1796:	c7 01       	movw	r24, r14
    1798:	68 ee       	ldi	r22, 0xE8	; 232
    179a:	73 e0       	ldi	r23, 0x03	; 3
    179c:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <__divmodhi4>
    17a0:	cb 01       	movw	r24, r22
    17a2:	70 93 97 06 	sts	0x0697, r23
    17a6:	60 93 96 06 	sts	0x0696, r22
		thousand = temp%10 + 48;
    17aa:	6a e0       	ldi	r22, 0x0A	; 10
    17ac:	70 e0       	ldi	r23, 0x00	; 0
    17ae:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <__udivmodhi4>
    17b2:	ac 01       	movw	r20, r24
    17b4:	40 5d       	subi	r20, 0xD0	; 208
    17b6:	5f 4f       	sbci	r21, 0xFF	; 255
    17b8:	50 93 9f 06 	sts	0x069F, r21
    17bc:	40 93 9e 06 	sts	0x069E, r20
		lcd_wr_char(row, column, thousand);
    17c0:	8d 2f       	mov	r24, r29
    17c2:	6c 2f       	mov	r22, r28
    17c4:	0e 94 49 0b 	call	0x1692	; 0x1692 <lcd_wr_char>
		column+=1;
    17c8:	cf 5f       	subi	r28, 0xFF	; 255
		flag = 1;
    17ca:	81 e0       	ldi	r24, 0x01	; 1
    17cc:	01 c0       	rjmp	.+2      	; 0x17d0 <lcd_numeric_value+0xb2>
		val = 0 - val;
		lcd_string(row, column, "-");
		column+=1;
	}
		
	unsigned char flag = 0;
    17ce:	80 e0       	ldi	r24, 0x00	; 0
		lcd_wr_char(row, column, thousand);
		column+=1;
		flag = 1;
	}
	
	if(digits == 3 || flag == 1)
    17d0:	03 30       	cpi	r16, 0x03	; 3
    17d2:	11 05       	cpc	r17, r1
    17d4:	11 f0       	breq	.+4      	; 0x17da <lcd_numeric_value+0xbc>
    17d6:	81 30       	cpi	r24, 0x01	; 1
    17d8:	d9 f4       	brne	.+54     	; 0x1810 <lcd_numeric_value+0xf2>
	{
		temp = val/100;
    17da:	c7 01       	movw	r24, r14
    17dc:	64 e6       	ldi	r22, 0x64	; 100
    17de:	70 e0       	ldi	r23, 0x00	; 0
    17e0:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <__divmodhi4>
    17e4:	cb 01       	movw	r24, r22
    17e6:	70 93 97 06 	sts	0x0697, r23
    17ea:	60 93 96 06 	sts	0x0696, r22
		hundred = temp%10 + 48;
    17ee:	6a e0       	ldi	r22, 0x0A	; 10
    17f0:	70 e0       	ldi	r23, 0x00	; 0
    17f2:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <__udivmodhi4>
    17f6:	ac 01       	movw	r20, r24
    17f8:	40 5d       	subi	r20, 0xD0	; 208
    17fa:	5f 4f       	sbci	r21, 0xFF	; 255
    17fc:	50 93 9b 06 	sts	0x069B, r21
    1800:	40 93 9a 06 	sts	0x069A, r20
		lcd_wr_char(row, column, hundred);
    1804:	8d 2f       	mov	r24, r29
    1806:	6c 2f       	mov	r22, r28
    1808:	0e 94 49 0b 	call	0x1692	; 0x1692 <lcd_wr_char>
		column+=1;
    180c:	cf 5f       	subi	r28, 0xFF	; 255
		flag = 1;
    180e:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	if(digits == 2 || flag == 1)
    1810:	02 30       	cpi	r16, 0x02	; 2
    1812:	11 05       	cpc	r17, r1
    1814:	11 f0       	breq	.+4      	; 0x181a <lcd_numeric_value+0xfc>
    1816:	81 30       	cpi	r24, 0x01	; 1
    1818:	d9 f4       	brne	.+54     	; 0x1850 <lcd_numeric_value+0x132>
	{
		temp = val/10;
    181a:	2a e0       	ldi	r18, 0x0A	; 10
    181c:	30 e0       	ldi	r19, 0x00	; 0
    181e:	c7 01       	movw	r24, r14
    1820:	b9 01       	movw	r22, r18
    1822:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <__divmodhi4>
    1826:	cb 01       	movw	r24, r22
    1828:	70 93 97 06 	sts	0x0697, r23
    182c:	60 93 96 06 	sts	0x0696, r22
		tens = temp%10 + 48;
    1830:	b9 01       	movw	r22, r18
    1832:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <__udivmodhi4>
    1836:	ac 01       	movw	r20, r24
    1838:	40 5d       	subi	r20, 0xD0	; 208
    183a:	5f 4f       	sbci	r21, 0xFF	; 255
    183c:	50 93 99 06 	sts	0x0699, r21
    1840:	40 93 98 06 	sts	0x0698, r20
		lcd_wr_char(row, column, tens);
    1844:	8d 2f       	mov	r24, r29
    1846:	6c 2f       	mov	r22, r28
    1848:	0e 94 49 0b 	call	0x1692	; 0x1692 <lcd_wr_char>
		column+=1;
    184c:	cf 5f       	subi	r28, 0xFF	; 255
		flag = 1;
    184e:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	if(digits == 1 || flag == 1)
    1850:	01 30       	cpi	r16, 0x01	; 1
    1852:	11 05       	cpc	r17, r1
    1854:	11 f0       	breq	.+4      	; 0x185a <lcd_numeric_value+0x13c>
    1856:	81 30       	cpi	r24, 0x01	; 1
    1858:	89 f4       	brne	.+34     	; 0x187c <lcd_numeric_value+0x15e>
	{
		unit = val%10 + 48;
    185a:	c7 01       	movw	r24, r14
    185c:	6a e0       	ldi	r22, 0x0A	; 10
    185e:	70 e0       	ldi	r23, 0x00	; 0
    1860:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <__divmodhi4>
    1864:	ac 01       	movw	r20, r24
    1866:	40 5d       	subi	r20, 0xD0	; 208
    1868:	5f 4f       	sbci	r21, 0xFF	; 255
    186a:	50 93 9d 06 	sts	0x069D, r21
    186e:	40 93 9c 06 	sts	0x069C, r20
		lcd_wr_char(row, column, unit);
    1872:	8d 2f       	mov	r24, r29
    1874:	6c 2f       	mov	r22, r28
    1876:	0e 94 49 0b 	call	0x1692	; 0x1692 <lcd_wr_char>
		column+=1;
    187a:	cf 5f       	subi	r28, 0xFF	; 255
	}
	
	if(digits > 5)
    187c:	06 30       	cpi	r16, 0x06	; 6
    187e:	11 05       	cpc	r17, r1
    1880:	2c f0       	brlt	.+10     	; 0x188c <lcd_numeric_value+0x16e>
	{
		lcd_wr_char(row, column, 'E');
    1882:	8d 2f       	mov	r24, r29
    1884:	6c 2f       	mov	r22, r28
    1886:	45 e4       	ldi	r20, 0x45	; 69
    1888:	0e 94 49 0b 	call	0x1692	; 0x1692 <lcd_wr_char>
		column+=1;
	}
}
    188c:	df 91       	pop	r29
    188e:	cf 91       	pop	r28
    1890:	1f 91       	pop	r17
    1892:	0f 91       	pop	r16
    1894:	ff 90       	pop	r15
    1896:	ef 90       	pop	r14
    1898:	08 95       	ret

0000189a <sd_card_send_command>:
}


// send command to SD card
unsigned char sd_card_send_command(unsigned char cmd, unsigned long arg)
{
    189a:	ff 92       	push	r15
    189c:	0f 93       	push	r16
    189e:	1f 93       	push	r17
    18a0:	cf 93       	push	r28
    18a2:	df 93       	push	r29
    18a4:	08 2f       	mov	r16, r24
    18a6:	c4 2f       	mov	r28, r20
    18a8:	15 2f       	mov	r17, r21
    18aa:	d6 2f       	mov	r29, r22
    18ac:	f7 2e       	mov	r15, r23
	unsigned char response, status;
	unsigned char sd_card_crc = 0xFF;

	set_bit(spi_port, MOSI);							// drive MOSI pin to HIGH for send
    18ae:	2a 9a       	sbi	0x05, 2	; 5
	
	spi_send_data(0xFF);
    18b0:	8f ef       	ldi	r24, 0xFF	; 255
    18b2:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <spi_send_data>
    18b6:	8f ef       	ldi	r24, 0xFF	; 255
    18b8:	9f e8       	ldi	r25, 0x8F	; 143
    18ba:	01 97       	sbiw	r24, 0x01	; 1
    18bc:	f1 f7       	brne	.-4      	; 0x18ba <sd_card_send_command+0x20>
    18be:	00 c0       	rjmp	.+0      	; 0x18c0 <sd_card_send_command+0x26>
    18c0:	00 00       	nop
	
	_delay_ms(10);
	
	spi_send_data(cmd | 0x40);							// send cmd with addition of number 64
    18c2:	80 2f       	mov	r24, r16
    18c4:	80 64       	ori	r24, 0x40	; 64
    18c6:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <spi_send_data>
	
	spi_send_data(arg >> 24);							// send four bytes of arguments
    18ca:	8f 2d       	mov	r24, r15
    18cc:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <spi_send_data>
	spi_send_data(arg >> 16);
    18d0:	8d 2f       	mov	r24, r29
    18d2:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <spi_send_data>
	spi_send_data(arg >> 8);
    18d6:	81 2f       	mov	r24, r17
    18d8:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <spi_send_data>
	spi_send_data(arg);
    18dc:	8c 2f       	mov	r24, r28
    18de:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <spi_send_data>
	
	if (cmd == GO_IDLE_STATE)							// correct CRC for GO_IDLE_STATE or CMD0 command
    18e2:	00 23       	and	r16, r16
    18e4:	21 f0       	breq	.+8      	; 0x18ee <sd_card_send_command+0x54>
	{
		sd_card_crc = 0x95;
	} 
	else if (cmd == SEND_IF_COND)						// correct CRC for SEND_IF_COND or CMD8 command
    18e6:	08 30       	cpi	r16, 0x08	; 8
    18e8:	21 f0       	breq	.+8      	; 0x18f2 <sd_card_send_command+0x58>

// send command to SD card
unsigned char sd_card_send_command(unsigned char cmd, unsigned long arg)
{
	unsigned char response, status;
	unsigned char sd_card_crc = 0xFF;
    18ea:	8f ef       	ldi	r24, 0xFF	; 255
    18ec:	03 c0       	rjmp	.+6      	; 0x18f4 <sd_card_send_command+0x5a>
	spi_send_data(arg >> 8);
	spi_send_data(arg);
	
	if (cmd == GO_IDLE_STATE)							// correct CRC for GO_IDLE_STATE or CMD0 command
	{
		sd_card_crc = 0x95;
    18ee:	85 e9       	ldi	r24, 0x95	; 149
    18f0:	01 c0       	rjmp	.+2      	; 0x18f4 <sd_card_send_command+0x5a>
	} 
	else if (cmd == SEND_IF_COND)						// correct CRC for SEND_IF_COND or CMD8 command
	{
		sd_card_crc = 0x87;
    18f2:	87 e8       	ldi	r24, 0x87	; 135
	}
	
	spi_send_data(sd_card_crc);							// send last byte of CRC
    18f4:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <spi_send_data>
	
	set_bit(spi_port, MISO);							// drive MISO pin to HIGH for receive
    18f8:	2b 9a       	sbi	0x05, 3	; 5
	
	for (int i = 0; ((response = spi_receive_data()) & 0x80) && i != 255; i++);
    18fa:	c0 e0       	ldi	r28, 0x00	; 0
    18fc:	d1 e0       	ldi	r29, 0x01	; 1
    18fe:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
    1902:	18 2f       	mov	r17, r24
    1904:	88 23       	and	r24, r24
    1906:	14 f4       	brge	.+4      	; 0x190c <sd_card_send_command+0x72>
    1908:	21 97       	sbiw	r28, 0x01	; 1
    190a:	c9 f7       	brne	.-14     	; 0x18fe <sd_card_send_command+0x64>
	
	if (response == 0x00 && cmd == READ_OCR)
    190c:	11 23       	and	r17, r17
    190e:	91 f4       	brne	.+36     	; 0x1934 <sd_card_send_command+0x9a>
    1910:	0a 33       	cpi	r16, 0x3A	; 58
    1912:	81 f4       	brne	.+32     	; 0x1934 <sd_card_send_command+0x9a>
	{
		status = spi_receive_data() & 0x40;
    1914:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
		
		if (status == 0x40)
    1918:	86 ff       	sbrs	r24, 6
    191a:	04 c0       	rjmp	.+8      	; 0x1924 <sd_card_send_command+0x8a>
		{
			SDHC_flag = 1;
    191c:	81 e0       	ldi	r24, 0x01	; 1
    191e:	80 93 84 06 	sts	0x0684, r24
    1922:	02 c0       	rjmp	.+4      	; 0x1928 <sd_card_send_command+0x8e>
			_delay_ms(500);
			*/
		} 
		else
		{
			SDHC_flag = 0;
    1924:	10 92 84 06 	sts	0x0684, r1
			lcd_string(1, 1, "card: not SDHC");
			_delay_ms(500);
			*/
		}
		
		spi_receive_data();
    1928:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
		spi_receive_data();
    192c:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
		spi_receive_data();
    1930:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
	}
	
	return response;
}
    1934:	81 2f       	mov	r24, r17
    1936:	df 91       	pop	r29
    1938:	cf 91       	pop	r28
    193a:	1f 91       	pop	r17
    193c:	0f 91       	pop	r16
    193e:	ff 90       	pop	r15
    1940:	08 95       	ret

00001942 <sd_card_init>:
#include "SPI.h"


// initialize SD card
unsigned char sd_card_init()
{
    1942:	cf 92       	push	r12
    1944:	df 92       	push	r13
    1946:	ef 92       	push	r14
    1948:	ff 92       	push	r15
    194a:	cf 93       	push	r28
    194c:	df 93       	push	r29
	unsigned char i, response;
	unsigned int retry = 0;
	unsigned long arg;
	
	spi_pin_config();
    194e:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <spi_pin_config>
	
	spi_init();
    1952:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <spi_init>
    1956:	ca e0       	ldi	r28, 0x0A	; 10
	
	for (i = 0; i < 10; i++)
	{
		spi_send_data(0xFF);
    1958:	8f ef       	ldi	r24, 0xFF	; 255
    195a:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <spi_send_data>
    195e:	c1 50       	subi	r28, 0x01	; 1
	
	spi_pin_config();
	
	spi_init();
	
	for (i = 0; i < 10; i++)
    1960:	d9 f7       	brne	.-10     	; 0x1958 <sd_card_init+0x16>
	{
		spi_send_data(0xFF);
	}
	
	spi_cs_low();				// start SPI communication by driving CS low
    1962:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <spi_cs_low>
	
	// resets the SD memory card (GO_IDLE_STATE or CMD0)
	
	do
	{
		response = sd_card_send_command(GO_IDLE_STATE, 0);
    1966:	80 e0       	ldi	r24, 0x00	; 0
    1968:	40 e0       	ldi	r20, 0x00	; 0
    196a:	50 e0       	ldi	r21, 0x00	; 0
    196c:	ba 01       	movw	r22, r20
    196e:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
    1972:	ce ef       	ldi	r28, 0xFE	; 254
    1974:	d0 e0       	ldi	r29, 0x00	; 0
    1976:	09 c0       	rjmp	.+18     	; 0x198a <sd_card_init+0x48>
    1978:	80 e0       	ldi	r24, 0x00	; 0
    197a:	40 e0       	ldi	r20, 0x00	; 0
    197c:	50 e0       	ldi	r21, 0x00	; 0
    197e:	ba 01       	movw	r22, r20
    1980:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
    1984:	21 97       	sbiw	r28, 0x01	; 1
		retry++;
		if (retry > 0xFE)		// time out, card not detected
    1986:	09 f4       	brne	.+2      	; 0x198a <sd_card_init+0x48>
    1988:	57 c0       	rjmp	.+174    	; 0x1a38 <sd_card_init+0xf6>
		{
			return 0;
		}
		
	} while (response != 0x01);
    198a:	81 30       	cpi	r24, 0x01	; 1
    198c:	a9 f7       	brne	.-22     	; 0x1978 <sd_card_init+0x36>
    198e:	5e c0       	rjmp	.+188    	; 0x1a4c <sd_card_init+0x10a>
	// send SD memory card interface condition to
	// provide supply voltage range and version (SEND_IF_COND or CMD8)
	
	do
	{
		response = sd_card_send_command(SEND_IF_COND, 0x1AA);
    1990:	88 e0       	ldi	r24, 0x08	; 8
    1992:	4a ea       	ldi	r20, 0xAA	; 170
    1994:	51 e0       	ldi	r21, 0x01	; 1
    1996:	60 e0       	ldi	r22, 0x00	; 0
    1998:	70 e0       	ldi	r23, 0x00	; 0
    199a:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
    199e:	21 97       	sbiw	r28, 0x01	; 1
		retry++;
		if (retry > 0xFE)
    19a0:	29 f4       	brne	.+10     	; 0x19ac <sd_card_init+0x6a>
		{
			card_type = 1;
    19a2:	81 e0       	ldi	r24, 0x01	; 1
    19a4:	80 93 8d 06 	sts	0x068D, r24
			return 0;
    19a8:	80 e0       	ldi	r24, 0x00	; 0
    19aa:	49 c0       	rjmp	.+146    	; 0x1a3e <sd_card_init+0xfc>
		}
		
	} while (response != 0x01);
    19ac:	81 30       	cpi	r24, 0x01	; 1
    19ae:	81 f7       	brne	.-32     	; 0x1990 <sd_card_init+0x4e>
	
	for (i = 0; i < 3; i++)
	{
		spi_receive_data();
    19b0:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
    19b4:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
    19b8:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
	}
	
	if (spi_receive_data() == 0xAA)
    19bc:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
    19c0:	8a 3a       	cpi	r24, 0xAA	; 170
    19c2:	49 f4       	brne	.+18     	; 0x19d6 <sd_card_init+0x94>
	{
		card_type = 2;
    19c4:	82 e0       	ldi	r24, 0x02	; 2
    19c6:	80 93 8d 06 	sts	0x068D, r24
	retry = 0;
	
	// for SDHC, send support information and
	// activate the card's initialization process (SDHC_SEND_OP_COND or ACMD41)
	
	arg = card_type == 2 ? 0x40000000 : 0;
    19ca:	cc 24       	eor	r12, r12
    19cc:	dd 24       	eor	r13, r13
    19ce:	76 01       	movw	r14, r12
    19d0:	68 94       	set
    19d2:	f6 f8       	bld	r15, 6
    19d4:	06 c0       	rjmp	.+12     	; 0x19e2 <sd_card_init+0xa0>
		_delay_ms(500);
		*/
	}
	else
	{
		card_type = 1;
    19d6:	81 e0       	ldi	r24, 0x01	; 1
    19d8:	80 93 8d 06 	sts	0x068D, r24
	retry = 0;
	
	// for SDHC, send support information and
	// activate the card's initialization process (SDHC_SEND_OP_COND or ACMD41)
	
	arg = card_type == 2 ? 0x40000000 : 0;
    19dc:	cc 24       	eor	r12, r12
    19de:	dd 24       	eor	r13, r13
    19e0:	76 01       	movw	r14, r12
	
	do
	{
		sd_card_send_command(APP_CMD, 0);
    19e2:	87 e3       	ldi	r24, 0x37	; 55
    19e4:	40 e0       	ldi	r20, 0x00	; 0
    19e6:	50 e0       	ldi	r21, 0x00	; 0
    19e8:	ba 01       	movw	r22, r20
    19ea:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
		response = sd_card_send_command(SDHC_SEND_OP_COND, arg);
    19ee:	89 e2       	ldi	r24, 0x29	; 41
    19f0:	b7 01       	movw	r22, r14
    19f2:	a6 01       	movw	r20, r12
    19f4:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
    19f8:	ce ef       	ldi	r28, 0xFE	; 254
    19fa:	d0 e0       	ldi	r29, 0x00	; 0
    19fc:	0d c0       	rjmp	.+26     	; 0x1a18 <sd_card_init+0xd6>
	
	arg = card_type == 2 ? 0x40000000 : 0;
	
	do
	{
		sd_card_send_command(APP_CMD, 0);
    19fe:	87 e3       	ldi	r24, 0x37	; 55
    1a00:	40 e0       	ldi	r20, 0x00	; 0
    1a02:	50 e0       	ldi	r21, 0x00	; 0
    1a04:	ba 01       	movw	r22, r20
    1a06:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
		response = sd_card_send_command(SDHC_SEND_OP_COND, arg);
    1a0a:	89 e2       	ldi	r24, 0x29	; 41
    1a0c:	b7 01       	movw	r22, r14
    1a0e:	a6 01       	movw	r20, r12
    1a10:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
    1a14:	21 97       	sbiw	r28, 0x01	; 1
		retry++;
		if (retry > 0xFE)
    1a16:	91 f0       	breq	.+36     	; 0x1a3c <sd_card_init+0xfa>
		{
			return 0;
		}
		
	} while (response != 0x00);
    1a18:	88 23       	and	r24, r24
    1a1a:	89 f7       	brne	.-30     	; 0x19fe <sd_card_init+0xbc>
	retry = 0;
	
	// reads the OCR (Operation Condition) register of a card,
	// CCS (card capacity status) bit is assigned to OCR[30] (CMD58)
	
	if (card_type == 2)
    1a1c:	80 91 8d 06 	lds	r24, 0x068D
    1a20:	82 30       	cpi	r24, 0x02	; 2
    1a22:	31 f4       	brne	.+12     	; 0x1a30 <sd_card_init+0xee>
	{
		sd_card_send_command(READ_OCR, 0);
    1a24:	8a e3       	ldi	r24, 0x3A	; 58
    1a26:	40 e0       	ldi	r20, 0x00	; 0
    1a28:	50 e0       	ldi	r21, 0x00	; 0
    1a2a:	ba 01       	movw	r22, r20
    1a2c:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
	}
	
	spi_cs_high();				// stop SPI communication by driving CS high
    1a30:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <spi_cs_high>
	
	return 1;
    1a34:	81 e0       	ldi	r24, 0x01	; 1
    1a36:	03 c0       	rjmp	.+6      	; 0x1a3e <sd_card_init+0xfc>
	{
		response = sd_card_send_command(GO_IDLE_STATE, 0);
		retry++;
		if (retry > 0xFE)		// time out, card not detected
		{
			return 0;
    1a38:	80 e0       	ldi	r24, 0x00	; 0
    1a3a:	01 c0       	rjmp	.+2      	; 0x1a3e <sd_card_init+0xfc>
		sd_card_send_command(APP_CMD, 0);
		response = sd_card_send_command(SDHC_SEND_OP_COND, arg);
		retry++;
		if (retry > 0xFE)
		{
			return 0;
    1a3c:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	spi_cs_high();				// stop SPI communication by driving CS high
	
	return 1;
}
    1a3e:	df 91       	pop	r29
    1a40:	cf 91       	pop	r28
    1a42:	ff 90       	pop	r15
    1a44:	ef 90       	pop	r14
    1a46:	df 90       	pop	r13
    1a48:	cf 90       	pop	r12
    1a4a:	08 95       	ret
	// send SD memory card interface condition to
	// provide supply voltage range and version (SEND_IF_COND or CMD8)
	
	do
	{
		response = sd_card_send_command(SEND_IF_COND, 0x1AA);
    1a4c:	88 e0       	ldi	r24, 0x08	; 8
    1a4e:	4a ea       	ldi	r20, 0xAA	; 170
    1a50:	51 e0       	ldi	r21, 0x01	; 1
    1a52:	60 e0       	ldi	r22, 0x00	; 0
    1a54:	70 e0       	ldi	r23, 0x00	; 0
    1a56:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
    1a5a:	ce ef       	ldi	r28, 0xFE	; 254
    1a5c:	d0 e0       	ldi	r29, 0x00	; 0
    1a5e:	a6 cf       	rjmp	.-180    	; 0x19ac <sd_card_init+0x6a>

00001a60 <read_single_block>:
}


// read single block of data from SD card
unsigned char read_single_block(unsigned int block_addr)
{
    1a60:	cf 92       	push	r12
    1a62:	df 92       	push	r13
    1a64:	ef 92       	push	r14
    1a66:	ff 92       	push	r15
    1a68:	0f 93       	push	r16
    1a6a:	1f 93       	push	r17
    1a6c:	cf 93       	push	r28
    1a6e:	df 93       	push	r29
    1a70:	ec 01       	movw	r28, r24
	unsigned char response;
	unsigned int i, retry = 0;
	
	spi_cs_low();				// start SPI communication by driving CS low
    1a72:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <spi_cs_low>
	
	// ask the SD card to read from block_addr (READ_SINGLE_BLOCK or CMD17)
	
	do
	{
		response = sd_card_send_command(READ_SINGLE_BLOCK, block_addr);
    1a76:	6e 01       	movw	r12, r28
    1a78:	ee 24       	eor	r14, r14
    1a7a:	ff 24       	eor	r15, r15
    1a7c:	81 e1       	ldi	r24, 0x11	; 17
    1a7e:	b7 01       	movw	r22, r14
    1a80:	a6 01       	movw	r20, r12
    1a82:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
    1a86:	ce ef       	ldi	r28, 0xFE	; 254
    1a88:	d0 e0       	ldi	r29, 0x00	; 0
    1a8a:	07 c0       	rjmp	.+14     	; 0x1a9a <read_single_block+0x3a>
    1a8c:	81 e1       	ldi	r24, 0x11	; 17
    1a8e:	b7 01       	movw	r22, r14
    1a90:	a6 01       	movw	r20, r12
    1a92:	0e 94 4d 0c 	call	0x189a	; 0x189a <sd_card_send_command>
    1a96:	21 97       	sbiw	r28, 0x01	; 1
		retry++;
		if (retry > 0xFE)		// time out, card not detected
    1a98:	21 f1       	breq	.+72     	; 0x1ae2 <read_single_block+0x82>
		{
			return 0;
		}
		
	} while (response != 0x00);
    1a9a:	88 23       	and	r24, r24
    1a9c:	b9 f7       	brne	.-18     	; 0x1a8c <read_single_block+0x2c>
    1a9e:	c0 e0       	ldi	r28, 0x00	; 0
    1aa0:	d1 e0       	ldi	r29, 0x01	; 1
    1aa2:	02 c0       	rjmp	.+4      	; 0x1aa8 <read_single_block+0x48>
    1aa4:	21 97       	sbiw	r28, 0x01	; 1
	retry = 0;
	
	// wait for start block token (0xFE)
	while (spi_receive_data() != 0xFE)
	{
		if (retry++ > 0xFE)
    1aa6:	f9 f0       	breq	.+62     	; 0x1ae6 <read_single_block+0x86>
	} while (response != 0x00);
	
	retry = 0;
	
	// wait for start block token (0xFE)
	while (spi_receive_data() != 0xFE)
    1aa8:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
    1aac:	8e 3f       	cpi	r24, 0xFE	; 254
    1aae:	d1 f7       	brne	.-12     	; 0x1aa4 <read_single_block+0x44>
    1ab0:	c0 e8       	ldi	r28, 0x80	; 128
    1ab2:	d4 e0       	ldi	r29, 0x04	; 4
	return response;
}


// read single block of data from SD card
unsigned char read_single_block(unsigned int block_addr)
    1ab4:	00 e8       	ldi	r16, 0x80	; 128
    1ab6:	16 e0       	ldi	r17, 0x06	; 6
    1ab8:	fe 01       	movw	r30, r28
	_delay_ms(500);
	*/
	// empty the buffer
	for (i = 0; i < 512; i++)
	{
		buffer[i] = 0;
    1aba:	11 92       	st	Z+, r1
	lcd_clear();
	lcd_string(1, 1, "card: start read");
	_delay_ms(500);
	*/
	// empty the buffer
	for (i = 0; i < 512; i++)
    1abc:	e0 17       	cp	r30, r16
    1abe:	f1 07       	cpc	r31, r17
    1ac0:	e1 f7       	brne	.-8      	; 0x1aba <read_single_block+0x5a>
	}
	
	// read a block of data
	for (i = 0; i < 512; i++)
	{
		buffer[i] = spi_receive_data();
    1ac2:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
    1ac6:	89 93       	st	Y+, r24
	{
		buffer[i] = 0;
	}
	
	// read a block of data
	for (i = 0; i < 512; i++)
    1ac8:	c0 17       	cp	r28, r16
    1aca:	d1 07       	cpc	r29, r17
    1acc:	d1 f7       	brne	.-12     	; 0x1ac2 <read_single_block+0x62>
			lcd_numeric_value(1, 8, i, 3);
			_delay_ms(500);
		}*/
	}
	
	spi_receive_data();			// receive incoming CRC (16-bit), CRC is ignored here
    1ace:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
	spi_receive_data();
    1ad2:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
	
	spi_receive_data();			// extra 8 SCK pulses
    1ad6:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <spi_receive_data>
	
	spi_cs_high();				// stop SPI communication by driving CS high
    1ada:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <spi_cs_high>
	
	return 1;
    1ade:	81 e0       	ldi	r24, 0x01	; 1
    1ae0:	03 c0       	rjmp	.+6      	; 0x1ae8 <read_single_block+0x88>
	{
		response = sd_card_send_command(READ_SINGLE_BLOCK, block_addr);
		retry++;
		if (retry > 0xFE)		// time out, card not detected
		{
			return 0;
    1ae2:	80 e0       	ldi	r24, 0x00	; 0
    1ae4:	01 c0       	rjmp	.+2      	; 0x1ae8 <read_single_block+0x88>
	// wait for start block token (0xFE)
	while (spi_receive_data() != 0xFE)
	{
		if (retry++ > 0xFE)
		{
			return 0;
    1ae6:	80 e0       	ldi	r24, 0x00	; 0
	spi_receive_data();			// extra 8 SCK pulses
	
	spi_cs_high();				// stop SPI communication by driving CS high
	
	return 1;
}
    1ae8:	df 91       	pop	r29
    1aea:	cf 91       	pop	r28
    1aec:	1f 91       	pop	r17
    1aee:	0f 91       	pop	r16
    1af0:	ff 90       	pop	r15
    1af2:	ef 90       	pop	r14
    1af4:	df 90       	pop	r13
    1af6:	cf 90       	pop	r12
    1af8:	08 95       	ret

00001afa <spi_pin_config>:


// to configure the SPI pins
void spi_pin_config()
{
	DDRB = DDRB | ((1 << CS) | (1 << SCK) | (1 << MOSI));		// set only SS, SCK and MOSI pins as output and MISO as input
    1afa:	84 b1       	in	r24, 0x04	; 4
    1afc:	87 60       	ori	r24, 0x07	; 7
    1afe:	84 b9       	out	0x04, r24	; 4
	PORTB = PORTB | ((1 << CS) | (1 << SCK) | (1 << MOSI));
    1b00:	85 b1       	in	r24, 0x05	; 5
    1b02:	87 60       	ori	r24, 0x07	; 7
    1b04:	85 b9       	out	0x05, r24	; 5
}
    1b06:	08 95       	ret

00001b08 <spi_init>:


// to initialize SPI protocol
void spi_init()
{
	SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1) | (1 << SPR0);
    1b08:	83 e5       	ldi	r24, 0x53	; 83
    1b0a:	8c bd       	out	0x2c, r24	; 44
	SPSR = 0x00;
    1b0c:	1d bc       	out	0x2d, r1	; 45
	SPDR = 0x00;
    1b0e:	1e bc       	out	0x2e, r1	; 46
}
    1b10:	08 95       	ret

00001b12 <spi_cs_low>:


// start SPI communication by making CS low
void spi_cs_low()
{
	clear_bit(PORTB, CS);
    1b12:	28 98       	cbi	0x05, 0	; 5
}
    1b14:	08 95       	ret

00001b16 <spi_cs_high>:


// stop SPI communication by making CS high
void spi_cs_high()
{
	set_bit(PORTB, CS);
    1b16:	28 9a       	sbi	0x05, 0	; 5
}
    1b18:	08 95       	ret

00001b1a <spi_send_data>:


// send data to slave
unsigned char spi_send_data(unsigned char data)
{
	SPDR = data;
    1b1a:	8e bd       	out	0x2e, r24	; 46
	
	asm volatile("nop");
    1b1c:	00 00       	nop
	
	while(!(SPSR & (1<<SPIF)));		// wait for transmission to complete
    1b1e:	0d b4       	in	r0, 0x2d	; 45
    1b20:	07 fe       	sbrs	r0, 7
    1b22:	fd cf       	rjmp	.-6      	; 0x1b1e <spi_send_data+0x4>
	
	data = SPDR;
    1b24:	8e b5       	in	r24, 0x2e	; 46
	
	return data;
}
    1b26:	08 95       	ret

00001b28 <spi_receive_data>:
// receive data from slave
unsigned char spi_receive_data()
{
	unsigned char data;
	
	spi_send_data(0xFF);			// send dummy data to slave
    1b28:	8f ef       	ldi	r24, 0xFF	; 255
    1b2a:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <spi_send_data>
	
	data = SPDR;
    1b2e:	8e b5       	in	r24, 0x2e	; 46
	
	return data;
}
    1b30:	08 95       	ret

00001b32 <__divsf3>:
    1b32:	0c d0       	rcall	.+24     	; 0x1b4c <__divsf3x>
    1b34:	e6 c0       	rjmp	.+460    	; 0x1d02 <__fp_round>
    1b36:	de d0       	rcall	.+444    	; 0x1cf4 <__fp_pscB>
    1b38:	40 f0       	brcs	.+16     	; 0x1b4a <__divsf3+0x18>
    1b3a:	d5 d0       	rcall	.+426    	; 0x1ce6 <__fp_pscA>
    1b3c:	30 f0       	brcs	.+12     	; 0x1b4a <__divsf3+0x18>
    1b3e:	21 f4       	brne	.+8      	; 0x1b48 <__divsf3+0x16>
    1b40:	5f 3f       	cpi	r21, 0xFF	; 255
    1b42:	19 f0       	breq	.+6      	; 0x1b4a <__divsf3+0x18>
    1b44:	c7 c0       	rjmp	.+398    	; 0x1cd4 <__fp_inf>
    1b46:	51 11       	cpse	r21, r1
    1b48:	10 c1       	rjmp	.+544    	; 0x1d6a <__fp_szero>
    1b4a:	ca c0       	rjmp	.+404    	; 0x1ce0 <__fp_nan>

00001b4c <__divsf3x>:
    1b4c:	eb d0       	rcall	.+470    	; 0x1d24 <__fp_split3>
    1b4e:	98 f3       	brcs	.-26     	; 0x1b36 <__divsf3+0x4>

00001b50 <__divsf3_pse>:
    1b50:	99 23       	and	r25, r25
    1b52:	c9 f3       	breq	.-14     	; 0x1b46 <__divsf3+0x14>
    1b54:	55 23       	and	r21, r21
    1b56:	b1 f3       	breq	.-20     	; 0x1b44 <__divsf3+0x12>
    1b58:	95 1b       	sub	r25, r21
    1b5a:	55 0b       	sbc	r21, r21
    1b5c:	bb 27       	eor	r27, r27
    1b5e:	aa 27       	eor	r26, r26
    1b60:	62 17       	cp	r22, r18
    1b62:	73 07       	cpc	r23, r19
    1b64:	84 07       	cpc	r24, r20
    1b66:	38 f0       	brcs	.+14     	; 0x1b76 <__divsf3_pse+0x26>
    1b68:	9f 5f       	subi	r25, 0xFF	; 255
    1b6a:	5f 4f       	sbci	r21, 0xFF	; 255
    1b6c:	22 0f       	add	r18, r18
    1b6e:	33 1f       	adc	r19, r19
    1b70:	44 1f       	adc	r20, r20
    1b72:	aa 1f       	adc	r26, r26
    1b74:	a9 f3       	breq	.-22     	; 0x1b60 <__divsf3_pse+0x10>
    1b76:	33 d0       	rcall	.+102    	; 0x1bde <__divsf3_pse+0x8e>
    1b78:	0e 2e       	mov	r0, r30
    1b7a:	3a f0       	brmi	.+14     	; 0x1b8a <__divsf3_pse+0x3a>
    1b7c:	e0 e8       	ldi	r30, 0x80	; 128
    1b7e:	30 d0       	rcall	.+96     	; 0x1be0 <__divsf3_pse+0x90>
    1b80:	91 50       	subi	r25, 0x01	; 1
    1b82:	50 40       	sbci	r21, 0x00	; 0
    1b84:	e6 95       	lsr	r30
    1b86:	00 1c       	adc	r0, r0
    1b88:	ca f7       	brpl	.-14     	; 0x1b7c <__divsf3_pse+0x2c>
    1b8a:	29 d0       	rcall	.+82     	; 0x1bde <__divsf3_pse+0x8e>
    1b8c:	fe 2f       	mov	r31, r30
    1b8e:	27 d0       	rcall	.+78     	; 0x1bde <__divsf3_pse+0x8e>
    1b90:	66 0f       	add	r22, r22
    1b92:	77 1f       	adc	r23, r23
    1b94:	88 1f       	adc	r24, r24
    1b96:	bb 1f       	adc	r27, r27
    1b98:	26 17       	cp	r18, r22
    1b9a:	37 07       	cpc	r19, r23
    1b9c:	48 07       	cpc	r20, r24
    1b9e:	ab 07       	cpc	r26, r27
    1ba0:	b0 e8       	ldi	r27, 0x80	; 128
    1ba2:	09 f0       	breq	.+2      	; 0x1ba6 <__divsf3_pse+0x56>
    1ba4:	bb 0b       	sbc	r27, r27
    1ba6:	80 2d       	mov	r24, r0
    1ba8:	bf 01       	movw	r22, r30
    1baa:	ff 27       	eor	r31, r31
    1bac:	93 58       	subi	r25, 0x83	; 131
    1bae:	5f 4f       	sbci	r21, 0xFF	; 255
    1bb0:	2a f0       	brmi	.+10     	; 0x1bbc <__divsf3_pse+0x6c>
    1bb2:	9e 3f       	cpi	r25, 0xFE	; 254
    1bb4:	51 05       	cpc	r21, r1
    1bb6:	68 f0       	brcs	.+26     	; 0x1bd2 <__divsf3_pse+0x82>
    1bb8:	8d c0       	rjmp	.+282    	; 0x1cd4 <__fp_inf>
    1bba:	d7 c0       	rjmp	.+430    	; 0x1d6a <__fp_szero>
    1bbc:	5f 3f       	cpi	r21, 0xFF	; 255
    1bbe:	ec f3       	brlt	.-6      	; 0x1bba <__divsf3_pse+0x6a>
    1bc0:	98 3e       	cpi	r25, 0xE8	; 232
    1bc2:	dc f3       	brlt	.-10     	; 0x1bba <__divsf3_pse+0x6a>
    1bc4:	86 95       	lsr	r24
    1bc6:	77 95       	ror	r23
    1bc8:	67 95       	ror	r22
    1bca:	b7 95       	ror	r27
    1bcc:	f7 95       	ror	r31
    1bce:	9f 5f       	subi	r25, 0xFF	; 255
    1bd0:	c9 f7       	brne	.-14     	; 0x1bc4 <__divsf3_pse+0x74>
    1bd2:	88 0f       	add	r24, r24
    1bd4:	91 1d       	adc	r25, r1
    1bd6:	96 95       	lsr	r25
    1bd8:	87 95       	ror	r24
    1bda:	97 f9       	bld	r25, 7
    1bdc:	08 95       	ret
    1bde:	e1 e0       	ldi	r30, 0x01	; 1
    1be0:	66 0f       	add	r22, r22
    1be2:	77 1f       	adc	r23, r23
    1be4:	88 1f       	adc	r24, r24
    1be6:	bb 1f       	adc	r27, r27
    1be8:	62 17       	cp	r22, r18
    1bea:	73 07       	cpc	r23, r19
    1bec:	84 07       	cpc	r24, r20
    1bee:	ba 07       	cpc	r27, r26
    1bf0:	20 f0       	brcs	.+8      	; 0x1bfa <__divsf3_pse+0xaa>
    1bf2:	62 1b       	sub	r22, r18
    1bf4:	73 0b       	sbc	r23, r19
    1bf6:	84 0b       	sbc	r24, r20
    1bf8:	ba 0b       	sbc	r27, r26
    1bfa:	ee 1f       	adc	r30, r30
    1bfc:	88 f7       	brcc	.-30     	; 0x1be0 <__divsf3_pse+0x90>
    1bfe:	e0 95       	com	r30
    1c00:	08 95       	ret

00001c02 <__fixunssfsi>:
    1c02:	98 d0       	rcall	.+304    	; 0x1d34 <__fp_splitA>
    1c04:	88 f0       	brcs	.+34     	; 0x1c28 <__fixunssfsi+0x26>
    1c06:	9f 57       	subi	r25, 0x7F	; 127
    1c08:	90 f0       	brcs	.+36     	; 0x1c2e <__fixunssfsi+0x2c>
    1c0a:	b9 2f       	mov	r27, r25
    1c0c:	99 27       	eor	r25, r25
    1c0e:	b7 51       	subi	r27, 0x17	; 23
    1c10:	a0 f0       	brcs	.+40     	; 0x1c3a <__fixunssfsi+0x38>
    1c12:	d1 f0       	breq	.+52     	; 0x1c48 <__fixunssfsi+0x46>
    1c14:	66 0f       	add	r22, r22
    1c16:	77 1f       	adc	r23, r23
    1c18:	88 1f       	adc	r24, r24
    1c1a:	99 1f       	adc	r25, r25
    1c1c:	1a f0       	brmi	.+6      	; 0x1c24 <__fixunssfsi+0x22>
    1c1e:	ba 95       	dec	r27
    1c20:	c9 f7       	brne	.-14     	; 0x1c14 <__fixunssfsi+0x12>
    1c22:	12 c0       	rjmp	.+36     	; 0x1c48 <__fixunssfsi+0x46>
    1c24:	b1 30       	cpi	r27, 0x01	; 1
    1c26:	81 f0       	breq	.+32     	; 0x1c48 <__fixunssfsi+0x46>
    1c28:	9f d0       	rcall	.+318    	; 0x1d68 <__fp_zero>
    1c2a:	b1 e0       	ldi	r27, 0x01	; 1
    1c2c:	08 95       	ret
    1c2e:	9c c0       	rjmp	.+312    	; 0x1d68 <__fp_zero>
    1c30:	67 2f       	mov	r22, r23
    1c32:	78 2f       	mov	r23, r24
    1c34:	88 27       	eor	r24, r24
    1c36:	b8 5f       	subi	r27, 0xF8	; 248
    1c38:	39 f0       	breq	.+14     	; 0x1c48 <__fixunssfsi+0x46>
    1c3a:	b9 3f       	cpi	r27, 0xF9	; 249
    1c3c:	cc f3       	brlt	.-14     	; 0x1c30 <__fixunssfsi+0x2e>
    1c3e:	86 95       	lsr	r24
    1c40:	77 95       	ror	r23
    1c42:	67 95       	ror	r22
    1c44:	b3 95       	inc	r27
    1c46:	d9 f7       	brne	.-10     	; 0x1c3e <__fixunssfsi+0x3c>
    1c48:	3e f4       	brtc	.+14     	; 0x1c58 <__fixunssfsi+0x56>
    1c4a:	90 95       	com	r25
    1c4c:	80 95       	com	r24
    1c4e:	70 95       	com	r23
    1c50:	61 95       	neg	r22
    1c52:	7f 4f       	sbci	r23, 0xFF	; 255
    1c54:	8f 4f       	sbci	r24, 0xFF	; 255
    1c56:	9f 4f       	sbci	r25, 0xFF	; 255
    1c58:	08 95       	ret

00001c5a <__floatunsisf>:
    1c5a:	e8 94       	clt
    1c5c:	09 c0       	rjmp	.+18     	; 0x1c70 <__floatsisf+0x12>

00001c5e <__floatsisf>:
    1c5e:	97 fb       	bst	r25, 7
    1c60:	3e f4       	brtc	.+14     	; 0x1c70 <__floatsisf+0x12>
    1c62:	90 95       	com	r25
    1c64:	80 95       	com	r24
    1c66:	70 95       	com	r23
    1c68:	61 95       	neg	r22
    1c6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6c:	8f 4f       	sbci	r24, 0xFF	; 255
    1c6e:	9f 4f       	sbci	r25, 0xFF	; 255
    1c70:	99 23       	and	r25, r25
    1c72:	a9 f0       	breq	.+42     	; 0x1c9e <__floatsisf+0x40>
    1c74:	f9 2f       	mov	r31, r25
    1c76:	96 e9       	ldi	r25, 0x96	; 150
    1c78:	bb 27       	eor	r27, r27
    1c7a:	93 95       	inc	r25
    1c7c:	f6 95       	lsr	r31
    1c7e:	87 95       	ror	r24
    1c80:	77 95       	ror	r23
    1c82:	67 95       	ror	r22
    1c84:	b7 95       	ror	r27
    1c86:	f1 11       	cpse	r31, r1
    1c88:	f8 cf       	rjmp	.-16     	; 0x1c7a <__floatsisf+0x1c>
    1c8a:	fa f4       	brpl	.+62     	; 0x1cca <__floatsisf+0x6c>
    1c8c:	bb 0f       	add	r27, r27
    1c8e:	11 f4       	brne	.+4      	; 0x1c94 <__floatsisf+0x36>
    1c90:	60 ff       	sbrs	r22, 0
    1c92:	1b c0       	rjmp	.+54     	; 0x1cca <__floatsisf+0x6c>
    1c94:	6f 5f       	subi	r22, 0xFF	; 255
    1c96:	7f 4f       	sbci	r23, 0xFF	; 255
    1c98:	8f 4f       	sbci	r24, 0xFF	; 255
    1c9a:	9f 4f       	sbci	r25, 0xFF	; 255
    1c9c:	16 c0       	rjmp	.+44     	; 0x1cca <__floatsisf+0x6c>
    1c9e:	88 23       	and	r24, r24
    1ca0:	11 f0       	breq	.+4      	; 0x1ca6 <__floatsisf+0x48>
    1ca2:	96 e9       	ldi	r25, 0x96	; 150
    1ca4:	11 c0       	rjmp	.+34     	; 0x1cc8 <__floatsisf+0x6a>
    1ca6:	77 23       	and	r23, r23
    1ca8:	21 f0       	breq	.+8      	; 0x1cb2 <__floatsisf+0x54>
    1caa:	9e e8       	ldi	r25, 0x8E	; 142
    1cac:	87 2f       	mov	r24, r23
    1cae:	76 2f       	mov	r23, r22
    1cb0:	05 c0       	rjmp	.+10     	; 0x1cbc <__floatsisf+0x5e>
    1cb2:	66 23       	and	r22, r22
    1cb4:	71 f0       	breq	.+28     	; 0x1cd2 <__floatsisf+0x74>
    1cb6:	96 e8       	ldi	r25, 0x86	; 134
    1cb8:	86 2f       	mov	r24, r22
    1cba:	70 e0       	ldi	r23, 0x00	; 0
    1cbc:	60 e0       	ldi	r22, 0x00	; 0
    1cbe:	2a f0       	brmi	.+10     	; 0x1cca <__floatsisf+0x6c>
    1cc0:	9a 95       	dec	r25
    1cc2:	66 0f       	add	r22, r22
    1cc4:	77 1f       	adc	r23, r23
    1cc6:	88 1f       	adc	r24, r24
    1cc8:	da f7       	brpl	.-10     	; 0x1cc0 <__floatsisf+0x62>
    1cca:	88 0f       	add	r24, r24
    1ccc:	96 95       	lsr	r25
    1cce:	87 95       	ror	r24
    1cd0:	97 f9       	bld	r25, 7
    1cd2:	08 95       	ret

00001cd4 <__fp_inf>:
    1cd4:	97 f9       	bld	r25, 7
    1cd6:	9f 67       	ori	r25, 0x7F	; 127
    1cd8:	80 e8       	ldi	r24, 0x80	; 128
    1cda:	70 e0       	ldi	r23, 0x00	; 0
    1cdc:	60 e0       	ldi	r22, 0x00	; 0
    1cde:	08 95       	ret

00001ce0 <__fp_nan>:
    1ce0:	9f ef       	ldi	r25, 0xFF	; 255
    1ce2:	80 ec       	ldi	r24, 0xC0	; 192
    1ce4:	08 95       	ret

00001ce6 <__fp_pscA>:
    1ce6:	00 24       	eor	r0, r0
    1ce8:	0a 94       	dec	r0
    1cea:	16 16       	cp	r1, r22
    1cec:	17 06       	cpc	r1, r23
    1cee:	18 06       	cpc	r1, r24
    1cf0:	09 06       	cpc	r0, r25
    1cf2:	08 95       	ret

00001cf4 <__fp_pscB>:
    1cf4:	00 24       	eor	r0, r0
    1cf6:	0a 94       	dec	r0
    1cf8:	12 16       	cp	r1, r18
    1cfa:	13 06       	cpc	r1, r19
    1cfc:	14 06       	cpc	r1, r20
    1cfe:	05 06       	cpc	r0, r21
    1d00:	08 95       	ret

00001d02 <__fp_round>:
    1d02:	09 2e       	mov	r0, r25
    1d04:	03 94       	inc	r0
    1d06:	00 0c       	add	r0, r0
    1d08:	11 f4       	brne	.+4      	; 0x1d0e <__fp_round+0xc>
    1d0a:	88 23       	and	r24, r24
    1d0c:	52 f0       	brmi	.+20     	; 0x1d22 <__fp_round+0x20>
    1d0e:	bb 0f       	add	r27, r27
    1d10:	40 f4       	brcc	.+16     	; 0x1d22 <__fp_round+0x20>
    1d12:	bf 2b       	or	r27, r31
    1d14:	11 f4       	brne	.+4      	; 0x1d1a <__fp_round+0x18>
    1d16:	60 ff       	sbrs	r22, 0
    1d18:	04 c0       	rjmp	.+8      	; 0x1d22 <__fp_round+0x20>
    1d1a:	6f 5f       	subi	r22, 0xFF	; 255
    1d1c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d1e:	8f 4f       	sbci	r24, 0xFF	; 255
    1d20:	9f 4f       	sbci	r25, 0xFF	; 255
    1d22:	08 95       	ret

00001d24 <__fp_split3>:
    1d24:	57 fd       	sbrc	r21, 7
    1d26:	90 58       	subi	r25, 0x80	; 128
    1d28:	44 0f       	add	r20, r20
    1d2a:	55 1f       	adc	r21, r21
    1d2c:	59 f0       	breq	.+22     	; 0x1d44 <__fp_splitA+0x10>
    1d2e:	5f 3f       	cpi	r21, 0xFF	; 255
    1d30:	71 f0       	breq	.+28     	; 0x1d4e <__fp_splitA+0x1a>
    1d32:	47 95       	ror	r20

00001d34 <__fp_splitA>:
    1d34:	88 0f       	add	r24, r24
    1d36:	97 fb       	bst	r25, 7
    1d38:	99 1f       	adc	r25, r25
    1d3a:	61 f0       	breq	.+24     	; 0x1d54 <__fp_splitA+0x20>
    1d3c:	9f 3f       	cpi	r25, 0xFF	; 255
    1d3e:	79 f0       	breq	.+30     	; 0x1d5e <__fp_splitA+0x2a>
    1d40:	87 95       	ror	r24
    1d42:	08 95       	ret
    1d44:	12 16       	cp	r1, r18
    1d46:	13 06       	cpc	r1, r19
    1d48:	14 06       	cpc	r1, r20
    1d4a:	55 1f       	adc	r21, r21
    1d4c:	f2 cf       	rjmp	.-28     	; 0x1d32 <__fp_split3+0xe>
    1d4e:	46 95       	lsr	r20
    1d50:	f1 df       	rcall	.-30     	; 0x1d34 <__fp_splitA>
    1d52:	08 c0       	rjmp	.+16     	; 0x1d64 <__fp_splitA+0x30>
    1d54:	16 16       	cp	r1, r22
    1d56:	17 06       	cpc	r1, r23
    1d58:	18 06       	cpc	r1, r24
    1d5a:	99 1f       	adc	r25, r25
    1d5c:	f1 cf       	rjmp	.-30     	; 0x1d40 <__fp_splitA+0xc>
    1d5e:	86 95       	lsr	r24
    1d60:	71 05       	cpc	r23, r1
    1d62:	61 05       	cpc	r22, r1
    1d64:	08 94       	sec
    1d66:	08 95       	ret

00001d68 <__fp_zero>:
    1d68:	e8 94       	clt

00001d6a <__fp_szero>:
    1d6a:	bb 27       	eor	r27, r27
    1d6c:	66 27       	eor	r22, r22
    1d6e:	77 27       	eor	r23, r23
    1d70:	cb 01       	movw	r24, r22
    1d72:	97 f9       	bld	r25, 7
    1d74:	08 95       	ret

00001d76 <__mulsf3>:
    1d76:	0b d0       	rcall	.+22     	; 0x1d8e <__mulsf3x>
    1d78:	c4 cf       	rjmp	.-120    	; 0x1d02 <__fp_round>
    1d7a:	b5 df       	rcall	.-150    	; 0x1ce6 <__fp_pscA>
    1d7c:	28 f0       	brcs	.+10     	; 0x1d88 <__mulsf3+0x12>
    1d7e:	ba df       	rcall	.-140    	; 0x1cf4 <__fp_pscB>
    1d80:	18 f0       	brcs	.+6      	; 0x1d88 <__mulsf3+0x12>
    1d82:	95 23       	and	r25, r21
    1d84:	09 f0       	breq	.+2      	; 0x1d88 <__mulsf3+0x12>
    1d86:	a6 cf       	rjmp	.-180    	; 0x1cd4 <__fp_inf>
    1d88:	ab cf       	rjmp	.-170    	; 0x1ce0 <__fp_nan>
    1d8a:	11 24       	eor	r1, r1
    1d8c:	ee cf       	rjmp	.-36     	; 0x1d6a <__fp_szero>

00001d8e <__mulsf3x>:
    1d8e:	ca df       	rcall	.-108    	; 0x1d24 <__fp_split3>
    1d90:	a0 f3       	brcs	.-24     	; 0x1d7a <__mulsf3+0x4>

00001d92 <__mulsf3_pse>:
    1d92:	95 9f       	mul	r25, r21
    1d94:	d1 f3       	breq	.-12     	; 0x1d8a <__mulsf3+0x14>
    1d96:	95 0f       	add	r25, r21
    1d98:	50 e0       	ldi	r21, 0x00	; 0
    1d9a:	55 1f       	adc	r21, r21
    1d9c:	62 9f       	mul	r22, r18
    1d9e:	f0 01       	movw	r30, r0
    1da0:	72 9f       	mul	r23, r18
    1da2:	bb 27       	eor	r27, r27
    1da4:	f0 0d       	add	r31, r0
    1da6:	b1 1d       	adc	r27, r1
    1da8:	63 9f       	mul	r22, r19
    1daa:	aa 27       	eor	r26, r26
    1dac:	f0 0d       	add	r31, r0
    1dae:	b1 1d       	adc	r27, r1
    1db0:	aa 1f       	adc	r26, r26
    1db2:	64 9f       	mul	r22, r20
    1db4:	66 27       	eor	r22, r22
    1db6:	b0 0d       	add	r27, r0
    1db8:	a1 1d       	adc	r26, r1
    1dba:	66 1f       	adc	r22, r22
    1dbc:	82 9f       	mul	r24, r18
    1dbe:	22 27       	eor	r18, r18
    1dc0:	b0 0d       	add	r27, r0
    1dc2:	a1 1d       	adc	r26, r1
    1dc4:	62 1f       	adc	r22, r18
    1dc6:	73 9f       	mul	r23, r19
    1dc8:	b0 0d       	add	r27, r0
    1dca:	a1 1d       	adc	r26, r1
    1dcc:	62 1f       	adc	r22, r18
    1dce:	83 9f       	mul	r24, r19
    1dd0:	a0 0d       	add	r26, r0
    1dd2:	61 1d       	adc	r22, r1
    1dd4:	22 1f       	adc	r18, r18
    1dd6:	74 9f       	mul	r23, r20
    1dd8:	33 27       	eor	r19, r19
    1dda:	a0 0d       	add	r26, r0
    1ddc:	61 1d       	adc	r22, r1
    1dde:	23 1f       	adc	r18, r19
    1de0:	84 9f       	mul	r24, r20
    1de2:	60 0d       	add	r22, r0
    1de4:	21 1d       	adc	r18, r1
    1de6:	82 2f       	mov	r24, r18
    1de8:	76 2f       	mov	r23, r22
    1dea:	6a 2f       	mov	r22, r26
    1dec:	11 24       	eor	r1, r1
    1dee:	9f 57       	subi	r25, 0x7F	; 127
    1df0:	50 40       	sbci	r21, 0x00	; 0
    1df2:	8a f0       	brmi	.+34     	; 0x1e16 <__mulsf3_pse+0x84>
    1df4:	e1 f0       	breq	.+56     	; 0x1e2e <__mulsf3_pse+0x9c>
    1df6:	88 23       	and	r24, r24
    1df8:	4a f0       	brmi	.+18     	; 0x1e0c <__mulsf3_pse+0x7a>
    1dfa:	ee 0f       	add	r30, r30
    1dfc:	ff 1f       	adc	r31, r31
    1dfe:	bb 1f       	adc	r27, r27
    1e00:	66 1f       	adc	r22, r22
    1e02:	77 1f       	adc	r23, r23
    1e04:	88 1f       	adc	r24, r24
    1e06:	91 50       	subi	r25, 0x01	; 1
    1e08:	50 40       	sbci	r21, 0x00	; 0
    1e0a:	a9 f7       	brne	.-22     	; 0x1df6 <__mulsf3_pse+0x64>
    1e0c:	9e 3f       	cpi	r25, 0xFE	; 254
    1e0e:	51 05       	cpc	r21, r1
    1e10:	70 f0       	brcs	.+28     	; 0x1e2e <__mulsf3_pse+0x9c>
    1e12:	60 cf       	rjmp	.-320    	; 0x1cd4 <__fp_inf>
    1e14:	aa cf       	rjmp	.-172    	; 0x1d6a <__fp_szero>
    1e16:	5f 3f       	cpi	r21, 0xFF	; 255
    1e18:	ec f3       	brlt	.-6      	; 0x1e14 <__mulsf3_pse+0x82>
    1e1a:	98 3e       	cpi	r25, 0xE8	; 232
    1e1c:	dc f3       	brlt	.-10     	; 0x1e14 <__mulsf3_pse+0x82>
    1e1e:	86 95       	lsr	r24
    1e20:	77 95       	ror	r23
    1e22:	67 95       	ror	r22
    1e24:	b7 95       	ror	r27
    1e26:	f7 95       	ror	r31
    1e28:	e7 95       	ror	r30
    1e2a:	9f 5f       	subi	r25, 0xFF	; 255
    1e2c:	c1 f7       	brne	.-16     	; 0x1e1e <__mulsf3_pse+0x8c>
    1e2e:	fe 2b       	or	r31, r30
    1e30:	88 0f       	add	r24, r24
    1e32:	91 1d       	adc	r25, r1
    1e34:	96 95       	lsr	r25
    1e36:	87 95       	ror	r24
    1e38:	97 f9       	bld	r25, 7
    1e3a:	08 95       	ret

00001e3c <__mulsi3>:
    1e3c:	62 9f       	mul	r22, r18
    1e3e:	d0 01       	movw	r26, r0
    1e40:	73 9f       	mul	r23, r19
    1e42:	f0 01       	movw	r30, r0
    1e44:	82 9f       	mul	r24, r18
    1e46:	e0 0d       	add	r30, r0
    1e48:	f1 1d       	adc	r31, r1
    1e4a:	64 9f       	mul	r22, r20
    1e4c:	e0 0d       	add	r30, r0
    1e4e:	f1 1d       	adc	r31, r1
    1e50:	92 9f       	mul	r25, r18
    1e52:	f0 0d       	add	r31, r0
    1e54:	83 9f       	mul	r24, r19
    1e56:	f0 0d       	add	r31, r0
    1e58:	74 9f       	mul	r23, r20
    1e5a:	f0 0d       	add	r31, r0
    1e5c:	65 9f       	mul	r22, r21
    1e5e:	f0 0d       	add	r31, r0
    1e60:	99 27       	eor	r25, r25
    1e62:	72 9f       	mul	r23, r18
    1e64:	b0 0d       	add	r27, r0
    1e66:	e1 1d       	adc	r30, r1
    1e68:	f9 1f       	adc	r31, r25
    1e6a:	63 9f       	mul	r22, r19
    1e6c:	b0 0d       	add	r27, r0
    1e6e:	e1 1d       	adc	r30, r1
    1e70:	f9 1f       	adc	r31, r25
    1e72:	bd 01       	movw	r22, r26
    1e74:	cf 01       	movw	r24, r30
    1e76:	11 24       	eor	r1, r1
    1e78:	08 95       	ret

00001e7a <__udivmodhi4>:
    1e7a:	aa 1b       	sub	r26, r26
    1e7c:	bb 1b       	sub	r27, r27
    1e7e:	51 e1       	ldi	r21, 0x11	; 17
    1e80:	07 c0       	rjmp	.+14     	; 0x1e90 <__udivmodhi4_ep>

00001e82 <__udivmodhi4_loop>:
    1e82:	aa 1f       	adc	r26, r26
    1e84:	bb 1f       	adc	r27, r27
    1e86:	a6 17       	cp	r26, r22
    1e88:	b7 07       	cpc	r27, r23
    1e8a:	10 f0       	brcs	.+4      	; 0x1e90 <__udivmodhi4_ep>
    1e8c:	a6 1b       	sub	r26, r22
    1e8e:	b7 0b       	sbc	r27, r23

00001e90 <__udivmodhi4_ep>:
    1e90:	88 1f       	adc	r24, r24
    1e92:	99 1f       	adc	r25, r25
    1e94:	5a 95       	dec	r21
    1e96:	a9 f7       	brne	.-22     	; 0x1e82 <__udivmodhi4_loop>
    1e98:	80 95       	com	r24
    1e9a:	90 95       	com	r25
    1e9c:	bc 01       	movw	r22, r24
    1e9e:	cd 01       	movw	r24, r26
    1ea0:	08 95       	ret

00001ea2 <__divmodhi4>:
    1ea2:	97 fb       	bst	r25, 7
    1ea4:	09 2e       	mov	r0, r25
    1ea6:	07 26       	eor	r0, r23
    1ea8:	0a d0       	rcall	.+20     	; 0x1ebe <__divmodhi4_neg1>
    1eaa:	77 fd       	sbrc	r23, 7
    1eac:	04 d0       	rcall	.+8      	; 0x1eb6 <__divmodhi4_neg2>
    1eae:	e5 df       	rcall	.-54     	; 0x1e7a <__udivmodhi4>
    1eb0:	06 d0       	rcall	.+12     	; 0x1ebe <__divmodhi4_neg1>
    1eb2:	00 20       	and	r0, r0
    1eb4:	1a f4       	brpl	.+6      	; 0x1ebc <__divmodhi4_exit>

00001eb6 <__divmodhi4_neg2>:
    1eb6:	70 95       	com	r23
    1eb8:	61 95       	neg	r22
    1eba:	7f 4f       	sbci	r23, 0xFF	; 255

00001ebc <__divmodhi4_exit>:
    1ebc:	08 95       	ret

00001ebe <__divmodhi4_neg1>:
    1ebe:	f6 f7       	brtc	.-4      	; 0x1ebc <__divmodhi4_exit>
    1ec0:	90 95       	com	r25
    1ec2:	81 95       	neg	r24
    1ec4:	9f 4f       	sbci	r25, 0xFF	; 255
    1ec6:	08 95       	ret

00001ec8 <__udivmodsi4>:
    1ec8:	a1 e2       	ldi	r26, 0x21	; 33
    1eca:	1a 2e       	mov	r1, r26
    1ecc:	aa 1b       	sub	r26, r26
    1ece:	bb 1b       	sub	r27, r27
    1ed0:	fd 01       	movw	r30, r26
    1ed2:	0d c0       	rjmp	.+26     	; 0x1eee <__udivmodsi4_ep>

00001ed4 <__udivmodsi4_loop>:
    1ed4:	aa 1f       	adc	r26, r26
    1ed6:	bb 1f       	adc	r27, r27
    1ed8:	ee 1f       	adc	r30, r30
    1eda:	ff 1f       	adc	r31, r31
    1edc:	a2 17       	cp	r26, r18
    1ede:	b3 07       	cpc	r27, r19
    1ee0:	e4 07       	cpc	r30, r20
    1ee2:	f5 07       	cpc	r31, r21
    1ee4:	20 f0       	brcs	.+8      	; 0x1eee <__udivmodsi4_ep>
    1ee6:	a2 1b       	sub	r26, r18
    1ee8:	b3 0b       	sbc	r27, r19
    1eea:	e4 0b       	sbc	r30, r20
    1eec:	f5 0b       	sbc	r31, r21

00001eee <__udivmodsi4_ep>:
    1eee:	66 1f       	adc	r22, r22
    1ef0:	77 1f       	adc	r23, r23
    1ef2:	88 1f       	adc	r24, r24
    1ef4:	99 1f       	adc	r25, r25
    1ef6:	1a 94       	dec	r1
    1ef8:	69 f7       	brne	.-38     	; 0x1ed4 <__udivmodsi4_loop>
    1efa:	60 95       	com	r22
    1efc:	70 95       	com	r23
    1efe:	80 95       	com	r24
    1f00:	90 95       	com	r25
    1f02:	9b 01       	movw	r18, r22
    1f04:	ac 01       	movw	r20, r24
    1f06:	bd 01       	movw	r22, r26
    1f08:	cf 01       	movw	r24, r30
    1f0a:	08 95       	ret

00001f0c <__divmodsi4>:
    1f0c:	97 fb       	bst	r25, 7
    1f0e:	09 2e       	mov	r0, r25
    1f10:	05 26       	eor	r0, r21
    1f12:	0e d0       	rcall	.+28     	; 0x1f30 <__divmodsi4_neg1>
    1f14:	57 fd       	sbrc	r21, 7
    1f16:	04 d0       	rcall	.+8      	; 0x1f20 <__divmodsi4_neg2>
    1f18:	d7 df       	rcall	.-82     	; 0x1ec8 <__udivmodsi4>
    1f1a:	0a d0       	rcall	.+20     	; 0x1f30 <__divmodsi4_neg1>
    1f1c:	00 1c       	adc	r0, r0
    1f1e:	38 f4       	brcc	.+14     	; 0x1f2e <__divmodsi4_exit>

00001f20 <__divmodsi4_neg2>:
    1f20:	50 95       	com	r21
    1f22:	40 95       	com	r20
    1f24:	30 95       	com	r19
    1f26:	21 95       	neg	r18
    1f28:	3f 4f       	sbci	r19, 0xFF	; 255
    1f2a:	4f 4f       	sbci	r20, 0xFF	; 255
    1f2c:	5f 4f       	sbci	r21, 0xFF	; 255

00001f2e <__divmodsi4_exit>:
    1f2e:	08 95       	ret

00001f30 <__divmodsi4_neg1>:
    1f30:	f6 f7       	brtc	.-4      	; 0x1f2e <__divmodsi4_exit>
    1f32:	90 95       	com	r25
    1f34:	80 95       	com	r24
    1f36:	70 95       	com	r23
    1f38:	61 95       	neg	r22
    1f3a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f3c:	8f 4f       	sbci	r24, 0xFF	; 255
    1f3e:	9f 4f       	sbci	r25, 0xFF	; 255
    1f40:	08 95       	ret

00001f42 <_exit>:
    1f42:	f8 94       	cli

00001f44 <__stop_program>:
    1f44:	ff cf       	rjmp	.-2      	; 0x1f44 <__stop_program>
